// Generated by mpgen from /home/zaidmstrr/bitcoin/src/ipc/capnp/init.capnp

#ifndef CAPNP_INIT_CAPNP_PROXY_H
#define CAPNP_INIT_CAPNP_PROXY_H

#include <src/ipc/capnp/init.capnp.h>
#include <interfaces/chain.h>
#include <interfaces/echo.h>
#include <interfaces/init.h>
#include <interfaces/mining.h>
#include <mp/proxy.h>

#if defined(__GNUC__)
#pragma GCC diagnostic push
#if !defined(__has_warning)
#pragma GCC diagnostic ignored "-Wsuggest-override"
#elif __has_warning("-Wsuggest-override")
#pragma GCC diagnostic ignored "-Wsuggest-override"
#endif
#endif
namespace mp {
template<>
struct ProxyMethod<ipc::capnp::messages::Init::MakeEchoParams>
{
    static constexpr auto impl = &interfaces::Init::makeEcho;
};

template<>
struct ProxyMethod<ipc::capnp::messages::Init::MakeMiningParams>
{
    static constexpr auto impl = &interfaces::Init::makeMining;
};

template<>
struct ProxyMethod<ipc::capnp::messages::Init::MakeChainParams>
{
    static constexpr auto impl = &interfaces::Init::makeChain;
};

namespace init_fields {
struct ThreadMap
{
    template<typename S> static auto get(S&& s) -> decltype(s.getThreadMap()) { return s.getThreadMap(); }
    template<typename S> static bool has(S&& s) { return s.hasThreadMap(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setThreadMap(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initThreadMap(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantThreadMap(); }
    template<typename S> static void setWant(S&& s) { s.setWantThreadMap(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasThreadMap(); }
    template<typename S> static void setHas(S&& s) { s.setHasThreadMap(true); }
};
struct Context
{
    template<typename S> static auto get(S&& s) -> decltype(s.getContext()) { return s.getContext(); }
    template<typename S> static bool has(S&& s) { return s.hasContext(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setContext(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initContext(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantContext(); }
    template<typename S> static void setWant(S&& s) { s.setWantContext(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasContext(); }
    template<typename S> static void setHas(S&& s) { s.setHasContext(true); }
};
struct Result
{
    template<typename S> static auto get(S&& s) -> decltype(s.getResult()) { return s.getResult(); }
    template<typename S> static bool has(S&& s) { return s.hasResult(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setResult(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initResult(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantResult(); }
    template<typename S> static void setWant(S&& s) { s.setWantResult(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasResult(); }
    template<typename S> static void setHas(S&& s) { s.setHasResult(true); }
};
} // namespace init_fields

template<>
struct ProxyClient<ipc::capnp::messages::Init> final : public ProxyClientCustom<ipc::capnp::messages::Init, interfaces::Init>
{
public:
    using ProxyClientCustom::ProxyClientCustom;
    ~ProxyClient();
    using M0 = ProxyClientMethodTraits<ipc::capnp::messages::Init::ConstructParams>;
    static typename M0::Result construct(Super& super);
    using M1 = ProxyClientMethodTraits<ipc::capnp::messages::Init::MakeEchoParams>;
    typename M1::Result makeEcho();
    using M2 = ProxyClientMethodTraits<ipc::capnp::messages::Init::MakeMiningParams>;
    typename M2::Result makeMining();
    using M3 = ProxyClientMethodTraits<ipc::capnp::messages::Init::MakeChainParams>;
    typename M3::Result makeChain();
};

template<>
struct ProxyServer<ipc::capnp::messages::Init> : public ProxyServerCustom<ipc::capnp::messages::Init, interfaces::Init>
{
public:
    using ProxyServerCustom::ProxyServerCustom;
    ~ProxyServer();
    kj::Promise<void> construct(ConstructContext call_context) override;
    kj::Promise<void> makeEcho(MakeEchoContext call_context) override;
    kj::Promise<void> makeMining(MakeMiningContext call_context) override;
    kj::Promise<void> makeChain(MakeChainContext call_context) override;
};

template<>
struct ProxyType<interfaces::Init>
{
    using Type = interfaces::Init;
    using Message = ipc::capnp::messages::Init;
    using Client = ProxyClient<Message>;
    using Server = ProxyServer<Message>;
};
} // namespace mp
#if defined(__GNUC__)
#pragma GCC diagnostic pop
#endif
#endif
