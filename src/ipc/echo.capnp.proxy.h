// Generated by mpgen from /home/zaidmstrr/bitcoin/src/ipc/capnp/echo.capnp

#ifndef CAPNP_ECHO_CAPNP_PROXY_H
#define CAPNP_ECHO_CAPNP_PROXY_H

#include <src/ipc/capnp/echo.capnp.h>
#include <interfaces/echo.h>
#include <mp/proxy.h>

#if defined(__GNUC__)
#pragma GCC diagnostic push
#if !defined(__has_warning)
#pragma GCC diagnostic ignored "-Wsuggest-override"
#elif __has_warning("-Wsuggest-override")
#pragma GCC diagnostic ignored "-Wsuggest-override"
#endif
#endif
namespace mp {
template<>
struct ProxyMethod<ipc::capnp::messages::Echo::EchoParams>
{
    static constexpr auto impl = &interfaces::Echo::echo;
};

namespace echo_fields {
struct Context
{
    template<typename S> static auto get(S&& s) -> decltype(s.getContext()) { return s.getContext(); }
    template<typename S> static bool has(S&& s) { return s.hasContext(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setContext(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initContext(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantContext(); }
    template<typename S> static void setWant(S&& s) { s.setWantContext(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasContext(); }
    template<typename S> static void setHas(S&& s) { s.setHasContext(true); }
};
struct Echo
{
    template<typename S> static auto get(S&& s) -> decltype(s.getEcho()) { return s.getEcho(); }
    template<typename S> static bool has(S&& s) { return s.hasEcho(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setEcho(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initEcho(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantEcho(); }
    template<typename S> static void setWant(S&& s) { s.setWantEcho(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasEcho(); }
    template<typename S> static void setHas(S&& s) { s.setHasEcho(true); }
};
struct Result
{
    template<typename S> static auto get(S&& s) -> decltype(s.getResult()) { return s.getResult(); }
    template<typename S> static bool has(S&& s) { return s.hasResult(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setResult(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initResult(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantResult(); }
    template<typename S> static void setWant(S&& s) { s.setWantResult(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasResult(); }
    template<typename S> static void setHas(S&& s) { s.setHasResult(true); }
};
} // namespace echo_fields

template<>
struct ProxyClient<ipc::capnp::messages::Echo> final : public ProxyClientCustom<ipc::capnp::messages::Echo, interfaces::Echo>
{
public:
    using ProxyClientCustom::ProxyClientCustom;
    ~ProxyClient();
    using M0 = ProxyClientMethodTraits<ipc::capnp::messages::Echo::DestroyParams>;
    static typename M0::Result destroy(Super& super);
    using M1 = ProxyClientMethodTraits<ipc::capnp::messages::Echo::EchoParams>;
    typename M1::Result echo(M1::Param<0> echo);
};

template<>
struct ProxyServer<ipc::capnp::messages::Echo> : public ProxyServerCustom<ipc::capnp::messages::Echo, interfaces::Echo>
{
public:
    using ProxyServerCustom::ProxyServerCustom;
    ~ProxyServer();
    kj::Promise<void> destroy(DestroyContext call_context) override;
    kj::Promise<void> echo(EchoContext call_context) override;
};

template<>
struct ProxyType<interfaces::Echo>
{
    using Type = interfaces::Echo;
    using Message = ipc::capnp::messages::Echo;
    using Client = ProxyClient<Message>;
    using Server = ProxyServer<Message>;
};
} // namespace mp
#if defined(__GNUC__)
#pragma GCC diagnostic pop
#endif
#endif
