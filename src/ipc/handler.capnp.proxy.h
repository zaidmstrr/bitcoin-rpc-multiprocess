// Generated by mpgen from /home/zaidmstrr/bitcoin/src/ipc/capnp/handler.capnp

#ifndef CAPNP_HANDLER_CAPNP_PROXY_H
#define CAPNP_HANDLER_CAPNP_PROXY_H

#include <handler.capnp.h>
#include <interfaces/handler.h>
#include <mp/proxy.h>

#if defined(__GNUC__)
#pragma GCC diagnostic push
#if !defined(__has_warning)
#pragma GCC diagnostic ignored "-Wsuggest-override"
#elif __has_warning("-Wsuggest-override")
#pragma GCC diagnostic ignored "-Wsuggest-override"
#endif
#endif
namespace mp {
template<>
struct ProxyMethod<ipc::capnp::messages::Handler::DisconnectParams>
{
    static constexpr auto impl = &interfaces::Handler::disconnect;
};

namespace handler_fields {
struct Context
{
    template<typename S> static auto get(S&& s) -> decltype(s.getContext()) { return s.getContext(); }
    template<typename S> static bool has(S&& s) { return s.hasContext(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setContext(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initContext(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantContext(); }
    template<typename S> static void setWant(S&& s) { s.setWantContext(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasContext(); }
    template<typename S> static void setHas(S&& s) { s.setHasContext(true); }
};
} // namespace handler_fields

template<>
struct ProxyClient<ipc::capnp::messages::Handler> final : public ProxyClientCustom<ipc::capnp::messages::Handler, interfaces::Handler>
{
public:
    using ProxyClientCustom::ProxyClientCustom;
    ~ProxyClient();
    using M0 = ProxyClientMethodTraits<ipc::capnp::messages::Handler::DestroyParams>;
    static typename M0::Result destroy(Super& super);
    using M1 = ProxyClientMethodTraits<ipc::capnp::messages::Handler::DisconnectParams>;
    typename M1::Result disconnect();
};

template<>
struct ProxyServer<ipc::capnp::messages::Handler> : public ProxyServerCustom<ipc::capnp::messages::Handler, interfaces::Handler>
{
public:
    using ProxyServerCustom::ProxyServerCustom;
    ~ProxyServer();
    kj::Promise<void> destroy(DestroyContext call_context) override;
    kj::Promise<void> disconnect(DisconnectContext call_context) override;
};

template<>
struct ProxyType<interfaces::Handler>
{
    using Type = interfaces::Handler;
    using Message = ipc::capnp::messages::Handler;
    using Client = ProxyClient<Message>;
    using Server = ProxyServer<Message>;
};
} // namespace mp
#if defined(__GNUC__)
#pragma GCC diagnostic pop
#endif
#endif
