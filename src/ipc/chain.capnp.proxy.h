// Generated by mpgen from /home/zaidmstrr/bitcoin/src/ipc/capnp/chain.capnp

#ifndef CAPNP_CHAIN_CAPNP_PROXY_H
#define CAPNP_CHAIN_CAPNP_PROXY_H

#include <chain.capnp.h>
#include <interfaces/chain.h>
#include <rpc/server.h>
#include <mp/proxy.h>

#if defined(__GNUC__)
#pragma GCC diagnostic push
#if !defined(__has_warning)
#pragma GCC diagnostic ignored "-Wsuggest-override"
#elif __has_warning("-Wsuggest-override")
#pragma GCC diagnostic ignored "-Wsuggest-override"
#endif
#endif
namespace mp {
template<>
struct ProxyMethod<ipc::capnp::messages::Chain::GetHeightParams>
{
    static constexpr auto impl = &interfaces::Chain::getHeight;
};

template<>
struct ProxyMethod<ipc::capnp::messages::Chain::GetBlockHashParams>
{
    static constexpr auto impl = &interfaces::Chain::getBlockHash;
};

template<>
struct ProxyMethod<ipc::capnp::messages::Chain::HaveBlockOnDiskParams>
{
    static constexpr auto impl = &interfaces::Chain::haveBlockOnDisk;
};

template<>
struct ProxyMethod<ipc::capnp::messages::Chain::GetTipLocatorParams>
{
    static constexpr auto impl = &interfaces::Chain::getTipLocator;
};

template<>
struct ProxyMethod<ipc::capnp::messages::Chain::GetActiveChainLocatorParams>
{
    static constexpr auto impl = &interfaces::Chain::getActiveChainLocator;
};

template<>
struct ProxyMethod<ipc::capnp::messages::Chain::FindLocatorForkParams>
{
    static constexpr auto impl = &interfaces::Chain::findLocatorFork;
};

template<>
struct ProxyMethod<ipc::capnp::messages::Chain::HasBlockFilterIndexParams>
{
    static constexpr auto impl = &interfaces::Chain::hasBlockFilterIndex;
};

template<>
struct ProxyMethod<ipc::capnp::messages::Chain::BlockFilterMatchesAnyParams>
{
    static constexpr auto impl = &interfaces::Chain::blockFilterMatchesAny;
};

template<>
struct ProxyMethod<ipc::capnp::messages::Chain::FindBlockParams>
{
    static constexpr auto impl = &interfaces::Chain::findBlock;
};

template<>
struct ProxyMethod<ipc::capnp::messages::Chain::FindFirstBlockWithTimeAndHeightParams>
{
    static constexpr auto impl = &interfaces::Chain::findFirstBlockWithTimeAndHeight;
};

template<>
struct ProxyMethod<ipc::capnp::messages::Chain::FindAncestorByHeightParams>
{
    static constexpr auto impl = &interfaces::Chain::findAncestorByHeight;
};

template<>
struct ProxyMethod<ipc::capnp::messages::Chain::FindAncestorByHashParams>
{
    static constexpr auto impl = &interfaces::Chain::findAncestorByHash;
};

template<>
struct ProxyMethod<ipc::capnp::messages::Chain::FindCommonAncestorParams>
{
    static constexpr auto impl = &interfaces::Chain::findCommonAncestor;
};

template<>
struct ProxyMethod<ipc::capnp::messages::Chain::FindCoinsParams>
{
    static constexpr auto impl = &interfaces::Chain::findCoins;
};

template<>
struct ProxyMethod<ipc::capnp::messages::Chain::GuessVerificationProgressParams>
{
    static constexpr auto impl = &interfaces::Chain::guessVerificationProgress;
};

template<>
struct ProxyMethod<ipc::capnp::messages::Chain::HasBlocksParams>
{
    static constexpr auto impl = &interfaces::Chain::hasBlocks;
};

template<>
struct ProxyMethod<ipc::capnp::messages::Chain::IsRBFOptInParams>
{
    static constexpr auto impl = &interfaces::Chain::isRBFOptIn;
};

template<>
struct ProxyMethod<ipc::capnp::messages::Chain::IsInMempoolParams>
{
    static constexpr auto impl = &interfaces::Chain::isInMempool;
};

template<>
struct ProxyMethod<ipc::capnp::messages::Chain::HasDescendantsInMempoolParams>
{
    static constexpr auto impl = &interfaces::Chain::hasDescendantsInMempool;
};

template<>
struct ProxyMethod<ipc::capnp::messages::Chain::BroadcastTransactionParams>
{
    static constexpr auto impl = &interfaces::Chain::broadcastTransaction;
};

template<>
struct ProxyMethod<ipc::capnp::messages::Chain::GetTransactionAncestryParams>
{
    static constexpr auto impl = &interfaces::Chain::getTransactionAncestry;
};

template<>
struct ProxyMethod<ipc::capnp::messages::Chain::CalculateIndividualBumpFeesParams>
{
    static constexpr auto impl = &interfaces::Chain::calculateIndividualBumpFees;
};

template<>
struct ProxyMethod<ipc::capnp::messages::Chain::CalculateCombinedBumpFeeParams>
{
    static constexpr auto impl = &interfaces::Chain::calculateCombinedBumpFee;
};

template<>
struct ProxyMethod<ipc::capnp::messages::Chain::GetPackageLimitsParams>
{
    static constexpr auto impl = &interfaces::Chain::getPackageLimits;
};

template<>
struct ProxyMethod<ipc::capnp::messages::Chain::CheckChainLimitsParams>
{
    static constexpr auto impl = &interfaces::Chain::checkChainLimits;
};

template<>
struct ProxyMethod<ipc::capnp::messages::Chain::EstimateSmartFeeParams>
{
    static constexpr auto impl = &interfaces::Chain::estimateSmartFee;
};

template<>
struct ProxyMethod<ipc::capnp::messages::Chain::EstimateMaxBlocksParams>
{
    static constexpr auto impl = &interfaces::Chain::estimateMaxBlocks;
};

template<>
struct ProxyMethod<ipc::capnp::messages::Chain::MempoolMinFeeParams>
{
    static constexpr auto impl = &interfaces::Chain::mempoolMinFee;
};

template<>
struct ProxyMethod<ipc::capnp::messages::Chain::RelayMinFeeParams>
{
    static constexpr auto impl = &interfaces::Chain::relayMinFee;
};

template<>
struct ProxyMethod<ipc::capnp::messages::Chain::RelayIncrementalFeeParams>
{
    static constexpr auto impl = &interfaces::Chain::relayIncrementalFee;
};

template<>
struct ProxyMethod<ipc::capnp::messages::Chain::RelayDustFeeParams>
{
    static constexpr auto impl = &interfaces::Chain::relayDustFee;
};

template<>
struct ProxyMethod<ipc::capnp::messages::Chain::HavePrunedParams>
{
    static constexpr auto impl = &interfaces::Chain::havePruned;
};

template<>
struct ProxyMethod<ipc::capnp::messages::Chain::GetPruneHeightParams>
{
    static constexpr auto impl = &interfaces::Chain::getPruneHeight;
};

template<>
struct ProxyMethod<ipc::capnp::messages::Chain::IsReadyToBroadcastParams>
{
    static constexpr auto impl = &interfaces::Chain::isReadyToBroadcast;
};

template<>
struct ProxyMethod<ipc::capnp::messages::Chain::IsInitialBlockDownloadParams>
{
    static constexpr auto impl = &interfaces::Chain::isInitialBlockDownload;
};

template<>
struct ProxyMethod<ipc::capnp::messages::Chain::ShutdownRequestedParams>
{
    static constexpr auto impl = &interfaces::Chain::shutdownRequested;
};

template<>
struct ProxyMethod<ipc::capnp::messages::Chain::InitMessageParams>
{
    static constexpr auto impl = &interfaces::Chain::initMessage;
};

template<>
struct ProxyMethod<ipc::capnp::messages::Chain::InitWarningParams>
{
    static constexpr auto impl = &interfaces::Chain::initWarning;
};

template<>
struct ProxyMethod<ipc::capnp::messages::Chain::InitErrorParams>
{
    static constexpr auto impl = &interfaces::Chain::initError;
};

template<>
struct ProxyMethod<ipc::capnp::messages::Chain::ShowProgressParams>
{
    static constexpr auto impl = &interfaces::Chain::showProgress;
};

template<>
struct ProxyMethod<ipc::capnp::messages::Chain::HandleNotificationsParams>
{
    static constexpr auto impl = &interfaces::Chain::handleNotifications;
};

template<>
struct ProxyMethod<ipc::capnp::messages::Chain::WaitForNotificationsIfTipChangedParams>
{
    static constexpr auto impl = &interfaces::Chain::waitForNotificationsIfTipChanged;
};

template<>
struct ProxyMethod<ipc::capnp::messages::Chain::HandleRpcParams>
{
    static constexpr auto impl = &interfaces::Chain::handleRpc;
};

template<>
struct ProxyMethod<ipc::capnp::messages::Chain::RpcEnableDeprecatedParams>
{
    static constexpr auto impl = &interfaces::Chain::rpcEnableDeprecated;
};

template<>
struct ProxyMethod<ipc::capnp::messages::Chain::RpcRunLaterParams>
{
    static constexpr auto impl = &interfaces::Chain::rpcRunLater;
};

template<>
struct ProxyMethod<ipc::capnp::messages::Chain::GetSettingParams>
{
    static constexpr auto impl = &interfaces::Chain::getSetting;
};

template<>
struct ProxyMethod<ipc::capnp::messages::Chain::GetSettingsListParams>
{
    static constexpr auto impl = &interfaces::Chain::getSettingsList;
};

template<>
struct ProxyMethod<ipc::capnp::messages::Chain::GetRwSettingParams>
{
    static constexpr auto impl = &interfaces::Chain::getRwSetting;
};

template<>
struct ProxyMethod<ipc::capnp::messages::Chain::UpdateRwSettingParams>
{
    static constexpr auto impl = &interfaces::Chain::updateRwSetting;
};

template<>
struct ProxyMethod<ipc::capnp::messages::Chain::OverwriteRwSettingParams>
{
    static constexpr auto impl = &interfaces::Chain::overwriteRwSetting;
};

template<>
struct ProxyMethod<ipc::capnp::messages::Chain::DeleteRwSettingsParams>
{
    static constexpr auto impl = &interfaces::Chain::deleteRwSettings;
};

template<>
struct ProxyMethod<ipc::capnp::messages::Chain::RequestMempoolTransactionsParams>
{
    static constexpr auto impl = &interfaces::Chain::requestMempoolTransactions;
};

template<>
struct ProxyMethod<ipc::capnp::messages::Chain::HasAssumedValidChainParams>
{
    static constexpr auto impl = &interfaces::Chain::hasAssumedValidChain;
};

template<>
struct ProxyMethod<ipc::capnp::messages::ChainNotifications::TransactionAddedToMempoolParams>
{
    static constexpr auto impl = &interfaces::Chain::Notifications::transactionAddedToMempool;
};

template<>
struct ProxyMethod<ipc::capnp::messages::ChainNotifications::TransactionRemovedFromMempoolParams>
{
    static constexpr auto impl = &interfaces::Chain::Notifications::transactionRemovedFromMempool;
};

template<>
struct ProxyMethod<ipc::capnp::messages::ChainNotifications::BlockConnectedParams>
{
    static constexpr auto impl = &interfaces::Chain::Notifications::blockConnected;
};

template<>
struct ProxyMethod<ipc::capnp::messages::ChainNotifications::BlockDisconnectedParams>
{
    static constexpr auto impl = &interfaces::Chain::Notifications::blockDisconnected;
};

template<>
struct ProxyMethod<ipc::capnp::messages::ChainNotifications::UpdatedBlockTipParams>
{
    static constexpr auto impl = &interfaces::Chain::Notifications::updatedBlockTip;
};

template<>
struct ProxyMethod<ipc::capnp::messages::ChainNotifications::ChainStateFlushedParams>
{
    static constexpr auto impl = &interfaces::Chain::Notifications::chainStateFlushed;
};

template<>
struct ProxyMethod<ipc::capnp::messages::ChainClient::RegisterRpcsParams>
{
    static constexpr auto impl = &interfaces::ChainClient::registerRpcs;
};

template<>
struct ProxyMethod<ipc::capnp::messages::ChainClient::VerifyParams>
{
    static constexpr auto impl = &interfaces::ChainClient::verify;
};

template<>
struct ProxyMethod<ipc::capnp::messages::ChainClient::LoadParams>
{
    static constexpr auto impl = &interfaces::ChainClient::load;
};

template<>
struct ProxyMethod<ipc::capnp::messages::ChainClient::StartParams>
{
    static constexpr auto impl = &interfaces::ChainClient::start;
};

template<>
struct ProxyMethod<ipc::capnp::messages::ChainClient::FlushParams>
{
    static constexpr auto impl = &interfaces::ChainClient::flush;
};

template<>
struct ProxyMethod<ipc::capnp::messages::ChainClient::StopParams>
{
    static constexpr auto impl = &interfaces::ChainClient::stop;
};

template<>
struct ProxyMethod<ipc::capnp::messages::ChainClient::SetMockTimeParams>
{
    static constexpr auto impl = &interfaces::ChainClient::setMockTime;
};

template<>
struct ProxyMethod<ipc::capnp::messages::ChainClient::SchedulerMockForwardParams>
{
    static constexpr auto impl = &interfaces::ChainClient::schedulerMockForward;
};

template<>
struct ProxyMethod<ipc::capnp::messages::ActorCallback::CallParams>
{
    static constexpr auto impl = &ProxyCallback<CRPCCommand::Actor>::call;
};

template<>
struct ProxyMethod<ipc::capnp::messages::RunLaterCallback::CallParams>
{
    static constexpr auto impl = &ProxyCallback<std::function<void()>>::call;
};

template<>
struct ProxyMethod<ipc::capnp::messages::SettingsUpdateCallback::CallParams>
{
    static constexpr auto impl = &ProxyCallback<interfaces::SettingsUpdate>::call;
};

namespace chain_fields {
struct Context
{
    template<typename S> static auto get(S&& s) -> decltype(s.getContext()) { return s.getContext(); }
    template<typename S> static bool has(S&& s) { return s.hasContext(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setContext(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initContext(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantContext(); }
    template<typename S> static void setWant(S&& s) { s.setWantContext(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasContext(); }
    template<typename S> static void setHas(S&& s) { s.setHasContext(true); }
};
struct Result
{
    template<typename S> static auto get(S&& s) -> decltype(s.getResult()) { return s.getResult(); }
    template<typename S> static bool has(S&& s) { return s.hasResult(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setResult(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initResult(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantResult(); }
    template<typename S> static void setWant(S&& s) { s.setWantResult(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasResult(); }
    template<typename S> static void setHas(S&& s) { s.setHasResult(true); }
};
struct Height
{
    template<typename S> static auto get(S&& s) -> decltype(s.getHeight()) { return s.getHeight(); }
    template<typename S> static bool has(S&& s) { return s.hasHeight(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setHeight(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initHeight(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantHeight(); }
    template<typename S> static void setWant(S&& s) { s.setWantHeight(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasHeight(); }
    template<typename S> static void setHas(S&& s) { s.setHasHeight(true); }
};
struct BlockHash
{
    template<typename S> static auto get(S&& s) -> decltype(s.getBlockHash()) { return s.getBlockHash(); }
    template<typename S> static bool has(S&& s) { return s.hasBlockHash(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setBlockHash(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initBlockHash(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantBlockHash(); }
    template<typename S> static void setWant(S&& s) { s.setWantBlockHash(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasBlockHash(); }
    template<typename S> static void setHas(S&& s) { s.setHasBlockHash(true); }
};
struct Locator
{
    template<typename S> static auto get(S&& s) -> decltype(s.getLocator()) { return s.getLocator(); }
    template<typename S> static bool has(S&& s) { return s.hasLocator(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setLocator(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initLocator(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantLocator(); }
    template<typename S> static void setWant(S&& s) { s.setWantLocator(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasLocator(); }
    template<typename S> static void setHas(S&& s) { s.setHasLocator(true); }
};
struct FilterType
{
    template<typename S> static auto get(S&& s) -> decltype(s.getFilterType()) { return s.getFilterType(); }
    template<typename S> static bool has(S&& s) { return s.hasFilterType(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setFilterType(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initFilterType(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantFilterType(); }
    template<typename S> static void setWant(S&& s) { s.setWantFilterType(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasFilterType(); }
    template<typename S> static void setHas(S&& s) { s.setHasFilterType(true); }
};
struct FilterSet
{
    template<typename S> static auto get(S&& s) -> decltype(s.getFilterSet()) { return s.getFilterSet(); }
    template<typename S> static bool has(S&& s) { return s.hasFilterSet(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setFilterSet(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initFilterSet(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantFilterSet(); }
    template<typename S> static void setWant(S&& s) { s.setWantFilterSet(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasFilterSet(); }
    template<typename S> static void setHas(S&& s) { s.setHasFilterSet(true); }
};
struct Hash
{
    template<typename S> static auto get(S&& s) -> decltype(s.getHash()) { return s.getHash(); }
    template<typename S> static bool has(S&& s) { return s.hasHash(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setHash(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initHash(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantHash(); }
    template<typename S> static void setWant(S&& s) { s.setWantHash(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasHash(); }
    template<typename S> static void setHas(S&& s) { s.setHasHash(true); }
};
struct Block
{
    template<typename S> static auto get(S&& s) -> decltype(s.getBlock()) { return s.getBlock(); }
    template<typename S> static bool has(S&& s) { return s.hasBlock(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setBlock(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initBlock(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantBlock(); }
    template<typename S> static void setWant(S&& s) { s.setWantBlock(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasBlock(); }
    template<typename S> static void setHas(S&& s) { s.setHasBlock(true); }
};
struct MinTime
{
    template<typename S> static auto get(S&& s) -> decltype(s.getMinTime()) { return s.getMinTime(); }
    template<typename S> static bool has(S&& s) { return s.hasMinTime(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setMinTime(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initMinTime(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantMinTime(); }
    template<typename S> static void setWant(S&& s) { s.setWantMinTime(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasMinTime(); }
    template<typename S> static void setHas(S&& s) { s.setHasMinTime(true); }
};
struct MinHeight
{
    template<typename S> static auto get(S&& s) -> decltype(s.getMinHeight()) { return s.getMinHeight(); }
    template<typename S> static bool has(S&& s) { return s.hasMinHeight(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setMinHeight(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initMinHeight(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantMinHeight(); }
    template<typename S> static void setWant(S&& s) { s.setWantMinHeight(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasMinHeight(); }
    template<typename S> static void setHas(S&& s) { s.setHasMinHeight(true); }
};
struct AncestorHeight
{
    template<typename S> static auto get(S&& s) -> decltype(s.getAncestorHeight()) { return s.getAncestorHeight(); }
    template<typename S> static bool has(S&& s) { return s.hasAncestorHeight(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setAncestorHeight(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initAncestorHeight(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantAncestorHeight(); }
    template<typename S> static void setWant(S&& s) { s.setWantAncestorHeight(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasAncestorHeight(); }
    template<typename S> static void setHas(S&& s) { s.setHasAncestorHeight(true); }
};
struct Ancestor
{
    template<typename S> static auto get(S&& s) -> decltype(s.getAncestor()) { return s.getAncestor(); }
    template<typename S> static bool has(S&& s) { return s.hasAncestor(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setAncestor(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initAncestor(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantAncestor(); }
    template<typename S> static void setWant(S&& s) { s.setWantAncestor(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasAncestor(); }
    template<typename S> static void setHas(S&& s) { s.setHasAncestor(true); }
};
struct AncestorHash
{
    template<typename S> static auto get(S&& s) -> decltype(s.getAncestorHash()) { return s.getAncestorHash(); }
    template<typename S> static bool has(S&& s) { return s.hasAncestorHash(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setAncestorHash(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initAncestorHash(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantAncestorHash(); }
    template<typename S> static void setWant(S&& s) { s.setWantAncestorHash(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasAncestorHash(); }
    template<typename S> static void setHas(S&& s) { s.setHasAncestorHash(true); }
};
struct BlockHash1
{
    template<typename S> static auto get(S&& s) -> decltype(s.getBlockHash1()) { return s.getBlockHash1(); }
    template<typename S> static bool has(S&& s) { return s.hasBlockHash1(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setBlockHash1(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initBlockHash1(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantBlockHash1(); }
    template<typename S> static void setWant(S&& s) { s.setWantBlockHash1(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasBlockHash1(); }
    template<typename S> static void setHas(S&& s) { s.setHasBlockHash1(true); }
};
struct BlockHash2
{
    template<typename S> static auto get(S&& s) -> decltype(s.getBlockHash2()) { return s.getBlockHash2(); }
    template<typename S> static bool has(S&& s) { return s.hasBlockHash2(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setBlockHash2(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initBlockHash2(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantBlockHash2(); }
    template<typename S> static void setWant(S&& s) { s.setWantBlockHash2(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasBlockHash2(); }
    template<typename S> static void setHas(S&& s) { s.setHasBlockHash2(true); }
};
struct Block1
{
    template<typename S> static auto get(S&& s) -> decltype(s.getBlock1()) { return s.getBlock1(); }
    template<typename S> static bool has(S&& s) { return s.hasBlock1(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setBlock1(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initBlock1(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantBlock1(); }
    template<typename S> static void setWant(S&& s) { s.setWantBlock1(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasBlock1(); }
    template<typename S> static void setHas(S&& s) { s.setHasBlock1(true); }
};
struct Block2
{
    template<typename S> static auto get(S&& s) -> decltype(s.getBlock2()) { return s.getBlock2(); }
    template<typename S> static bool has(S&& s) { return s.hasBlock2(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setBlock2(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initBlock2(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantBlock2(); }
    template<typename S> static void setWant(S&& s) { s.setWantBlock2(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasBlock2(); }
    template<typename S> static void setHas(S&& s) { s.setHasBlock2(true); }
};
struct Coins
{
    template<typename S> static auto get(S&& s) -> decltype(s.getCoins()) { return s.getCoins(); }
    template<typename S> static bool has(S&& s) { return s.hasCoins(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setCoins(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initCoins(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantCoins(); }
    template<typename S> static void setWant(S&& s) { s.setWantCoins(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasCoins(); }
    template<typename S> static void setHas(S&& s) { s.setHasCoins(true); }
};
struct MaxHeight
{
    template<typename S> static auto get(S&& s) -> decltype(s.getMaxHeight()) { return s.getMaxHeight(); }
    template<typename S> static bool has(S&& s) { return s.hasMaxHeight(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setMaxHeight(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initMaxHeight(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantMaxHeight(); }
    template<typename S> static void setWant(S&& s) { s.setWantMaxHeight(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasMaxHeight(); }
    template<typename S> static void setHas(S&& s) { s.setHasMaxHeight(true); }
};
struct Tx
{
    template<typename S> static auto get(S&& s) -> decltype(s.getTx()) { return s.getTx(); }
    template<typename S> static bool has(S&& s) { return s.hasTx(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setTx(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initTx(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantTx(); }
    template<typename S> static void setWant(S&& s) { s.setWantTx(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasTx(); }
    template<typename S> static void setHas(S&& s) { s.setHasTx(true); }
};
struct Txid
{
    template<typename S> static auto get(S&& s) -> decltype(s.getTxid()) { return s.getTxid(); }
    template<typename S> static bool has(S&& s) { return s.hasTxid(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setTxid(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initTxid(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantTxid(); }
    template<typename S> static void setWant(S&& s) { s.setWantTxid(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasTxid(); }
    template<typename S> static void setHas(S&& s) { s.setHasTxid(true); }
};
struct MaxTxFee
{
    template<typename S> static auto get(S&& s) -> decltype(s.getMaxTxFee()) { return s.getMaxTxFee(); }
    template<typename S> static bool has(S&& s) { return s.hasMaxTxFee(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setMaxTxFee(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initMaxTxFee(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantMaxTxFee(); }
    template<typename S> static void setWant(S&& s) { s.setWantMaxTxFee(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasMaxTxFee(); }
    template<typename S> static void setHas(S&& s) { s.setHasMaxTxFee(true); }
};
struct Relay
{
    template<typename S> static auto get(S&& s) -> decltype(s.getRelay()) { return s.getRelay(); }
    template<typename S> static bool has(S&& s) { return s.hasRelay(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setRelay(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initRelay(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantRelay(); }
    template<typename S> static void setWant(S&& s) { s.setWantRelay(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasRelay(); }
    template<typename S> static void setHas(S&& s) { s.setHasRelay(true); }
};
struct Error
{
    template<typename S> static auto get(S&& s) -> decltype(s.getError()) { return s.getError(); }
    template<typename S> static bool has(S&& s) { return s.hasError(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setError(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initError(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantError(); }
    template<typename S> static void setWant(S&& s) { s.setWantError(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasError(); }
    template<typename S> static void setHas(S&& s) { s.setHasError(true); }
};
struct Ancestors
{
    template<typename S> static auto get(S&& s) -> decltype(s.getAncestors()) { return s.getAncestors(); }
    template<typename S> static bool has(S&& s) { return s.hasAncestors(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setAncestors(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initAncestors(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantAncestors(); }
    template<typename S> static void setWant(S&& s) { s.setWantAncestors(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasAncestors(); }
    template<typename S> static void setHas(S&& s) { s.setHasAncestors(true); }
};
struct Descendants
{
    template<typename S> static auto get(S&& s) -> decltype(s.getDescendants()) { return s.getDescendants(); }
    template<typename S> static bool has(S&& s) { return s.hasDescendants(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setDescendants(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initDescendants(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantDescendants(); }
    template<typename S> static void setWant(S&& s) { s.setWantDescendants(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasDescendants(); }
    template<typename S> static void setHas(S&& s) { s.setHasDescendants(true); }
};
struct Ancestorsize
{
    template<typename S> static auto get(S&& s) -> decltype(s.getAncestorsize()) { return s.getAncestorsize(); }
    template<typename S> static bool has(S&& s) { return s.hasAncestorsize(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setAncestorsize(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initAncestorsize(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantAncestorsize(); }
    template<typename S> static void setWant(S&& s) { s.setWantAncestorsize(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasAncestorsize(); }
    template<typename S> static void setHas(S&& s) { s.setHasAncestorsize(true); }
};
struct Ancestorfees
{
    template<typename S> static auto get(S&& s) -> decltype(s.getAncestorfees()) { return s.getAncestorfees(); }
    template<typename S> static bool has(S&& s) { return s.hasAncestorfees(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setAncestorfees(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initAncestorfees(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantAncestorfees(); }
    template<typename S> static void setWant(S&& s) { s.setWantAncestorfees(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasAncestorfees(); }
    template<typename S> static void setHas(S&& s) { s.setHasAncestorfees(true); }
};
struct Outpoints
{
    template<typename S> static auto get(S&& s) -> decltype(s.getOutpoints()) { return s.getOutpoints(); }
    template<typename S> static bool has(S&& s) { return s.hasOutpoints(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setOutpoints(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initOutpoints(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantOutpoints(); }
    template<typename S> static void setWant(S&& s) { s.setWantOutpoints(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasOutpoints(); }
    template<typename S> static void setHas(S&& s) { s.setHasOutpoints(true); }
};
struct TargetFeerate
{
    template<typename S> static auto get(S&& s) -> decltype(s.getTargetFeerate()) { return s.getTargetFeerate(); }
    template<typename S> static bool has(S&& s) { return s.hasTargetFeerate(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setTargetFeerate(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initTargetFeerate(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantTargetFeerate(); }
    template<typename S> static void setWant(S&& s) { s.setWantTargetFeerate(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasTargetFeerate(); }
    template<typename S> static void setHas(S&& s) { s.setHasTargetFeerate(true); }
};
struct NumBlocks
{
    template<typename S> static auto get(S&& s) -> decltype(s.getNumBlocks()) { return s.getNumBlocks(); }
    template<typename S> static bool has(S&& s) { return s.hasNumBlocks(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setNumBlocks(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initNumBlocks(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantNumBlocks(); }
    template<typename S> static void setWant(S&& s) { s.setWantNumBlocks(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasNumBlocks(); }
    template<typename S> static void setHas(S&& s) { s.setHasNumBlocks(true); }
};
struct Conservative
{
    template<typename S> static auto get(S&& s) -> decltype(s.getConservative()) { return s.getConservative(); }
    template<typename S> static bool has(S&& s) { return s.hasConservative(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setConservative(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initConservative(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantConservative(); }
    template<typename S> static void setWant(S&& s) { s.setWantConservative(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasConservative(); }
    template<typename S> static void setHas(S&& s) { s.setHasConservative(true); }
};
struct Calc
{
    template<typename S> static auto get(S&& s) -> decltype(s.getCalc()) { return s.getCalc(); }
    template<typename S> static bool has(S&& s) { return s.hasCalc(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setCalc(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initCalc(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantCalc(); }
    template<typename S> static void setWant(S&& s) { s.setWantCalc(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasCalc(); }
    template<typename S> static void setHas(S&& s) { s.setHasCalc(true); }
};
struct Message
{
    template<typename S> static auto get(S&& s) -> decltype(s.getMessage()) { return s.getMessage(); }
    template<typename S> static bool has(S&& s) { return s.hasMessage(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setMessage(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initMessage(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantMessage(); }
    template<typename S> static void setWant(S&& s) { s.setWantMessage(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasMessage(); }
    template<typename S> static void setHas(S&& s) { s.setHasMessage(true); }
};
struct Title
{
    template<typename S> static auto get(S&& s) -> decltype(s.getTitle()) { return s.getTitle(); }
    template<typename S> static bool has(S&& s) { return s.hasTitle(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setTitle(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initTitle(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantTitle(); }
    template<typename S> static void setWant(S&& s) { s.setWantTitle(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasTitle(); }
    template<typename S> static void setHas(S&& s) { s.setHasTitle(true); }
};
struct Progress
{
    template<typename S> static auto get(S&& s) -> decltype(s.getProgress()) { return s.getProgress(); }
    template<typename S> static bool has(S&& s) { return s.hasProgress(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setProgress(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initProgress(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantProgress(); }
    template<typename S> static void setWant(S&& s) { s.setWantProgress(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasProgress(); }
    template<typename S> static void setHas(S&& s) { s.setHasProgress(true); }
};
struct ResumePossible
{
    template<typename S> static auto get(S&& s) -> decltype(s.getResumePossible()) { return s.getResumePossible(); }
    template<typename S> static bool has(S&& s) { return s.hasResumePossible(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setResumePossible(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initResumePossible(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantResumePossible(); }
    template<typename S> static void setWant(S&& s) { s.setWantResumePossible(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasResumePossible(); }
    template<typename S> static void setHas(S&& s) { s.setHasResumePossible(true); }
};
struct Notifications
{
    template<typename S> static auto get(S&& s) -> decltype(s.getNotifications()) { return s.getNotifications(); }
    template<typename S> static bool has(S&& s) { return s.hasNotifications(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setNotifications(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initNotifications(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantNotifications(); }
    template<typename S> static void setWant(S&& s) { s.setWantNotifications(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasNotifications(); }
    template<typename S> static void setHas(S&& s) { s.setHasNotifications(true); }
};
struct OldTip
{
    template<typename S> static auto get(S&& s) -> decltype(s.getOldTip()) { return s.getOldTip(); }
    template<typename S> static bool has(S&& s) { return s.hasOldTip(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setOldTip(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initOldTip(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantOldTip(); }
    template<typename S> static void setWant(S&& s) { s.setWantOldTip(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasOldTip(); }
    template<typename S> static void setHas(S&& s) { s.setHasOldTip(true); }
};
struct Command
{
    template<typename S> static auto get(S&& s) -> decltype(s.getCommand()) { return s.getCommand(); }
    template<typename S> static bool has(S&& s) { return s.hasCommand(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setCommand(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initCommand(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantCommand(); }
    template<typename S> static void setWant(S&& s) { s.setWantCommand(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasCommand(); }
    template<typename S> static void setHas(S&& s) { s.setHasCommand(true); }
};
struct Method
{
    template<typename S> static auto get(S&& s) -> decltype(s.getMethod()) { return s.getMethod(); }
    template<typename S> static bool has(S&& s) { return s.hasMethod(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setMethod(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initMethod(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantMethod(); }
    template<typename S> static void setWant(S&& s) { s.setWantMethod(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasMethod(); }
    template<typename S> static void setHas(S&& s) { s.setHasMethod(true); }
};
struct Name
{
    template<typename S> static auto get(S&& s) -> decltype(s.getName()) { return s.getName(); }
    template<typename S> static bool has(S&& s) { return s.hasName(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setName(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initName(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantName(); }
    template<typename S> static void setWant(S&& s) { s.setWantName(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasName(); }
    template<typename S> static void setHas(S&& s) { s.setHasName(true); }
};
struct Fn
{
    template<typename S> static auto get(S&& s) -> decltype(s.getFn()) { return s.getFn(); }
    template<typename S> static bool has(S&& s) { return s.hasFn(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setFn(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initFn(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantFn(); }
    template<typename S> static void setWant(S&& s) { s.setWantFn(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasFn(); }
    template<typename S> static void setHas(S&& s) { s.setHasFn(true); }
};
struct Seconds
{
    template<typename S> static auto get(S&& s) -> decltype(s.getSeconds()) { return s.getSeconds(); }
    template<typename S> static bool has(S&& s) { return s.hasSeconds(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setSeconds(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initSeconds(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantSeconds(); }
    template<typename S> static void setWant(S&& s) { s.setWantSeconds(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasSeconds(); }
    template<typename S> static void setHas(S&& s) { s.setHasSeconds(true); }
};
struct Update
{
    template<typename S> static auto get(S&& s) -> decltype(s.getUpdate()) { return s.getUpdate(); }
    template<typename S> static bool has(S&& s) { return s.hasUpdate(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setUpdate(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initUpdate(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantUpdate(); }
    template<typename S> static void setWant(S&& s) { s.setWantUpdate(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasUpdate(); }
    template<typename S> static void setHas(S&& s) { s.setHasUpdate(true); }
};
struct Value
{
    template<typename S> static auto get(S&& s) -> decltype(s.getValue()) { return s.getValue(); }
    template<typename S> static bool has(S&& s) { return s.hasValue(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setValue(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initValue(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantValue(); }
    template<typename S> static void setWant(S&& s) { s.setWantValue(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasValue(); }
    template<typename S> static void setHas(S&& s) { s.setHasValue(true); }
};
struct Action
{
    template<typename S> static auto get(S&& s) -> decltype(s.getAction()) { return s.getAction(); }
    template<typename S> static bool has(S&& s) { return s.hasAction(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setAction(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initAction(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantAction(); }
    template<typename S> static void setWant(S&& s) { s.setWantAction(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasAction(); }
    template<typename S> static void setHas(S&& s) { s.setHasAction(true); }
};
struct Reason
{
    template<typename S> static auto get(S&& s) -> decltype(s.getReason()) { return s.getReason(); }
    template<typename S> static bool has(S&& s) { return s.hasReason(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setReason(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initReason(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantReason(); }
    template<typename S> static void setWant(S&& s) { s.setWantReason(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasReason(); }
    template<typename S> static void setHas(S&& s) { s.setHasReason(true); }
};
struct Role
{
    template<typename S> static auto get(S&& s) -> decltype(s.getRole()) { return s.getRole(); }
    template<typename S> static bool has(S&& s) { return s.hasRole(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setRole(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initRole(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantRole(); }
    template<typename S> static void setWant(S&& s) { s.setWantRole(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasRole(); }
    template<typename S> static void setHas(S&& s) { s.setHasRole(true); }
};
struct Scheduler
{
    template<typename S> static auto get(S&& s) -> decltype(s.getScheduler()) { return s.getScheduler(); }
    template<typename S> static bool has(S&& s) { return s.hasScheduler(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setScheduler(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initScheduler(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantScheduler(); }
    template<typename S> static void setWant(S&& s) { s.setWantScheduler(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasScheduler(); }
    template<typename S> static void setHas(S&& s) { s.setHasScheduler(true); }
};
struct Time
{
    template<typename S> static auto get(S&& s) -> decltype(s.getTime()) { return s.getTime(); }
    template<typename S> static bool has(S&& s) { return s.hasTime(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setTime(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initTime(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantTime(); }
    template<typename S> static void setWant(S&& s) { s.setWantTime(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasTime(); }
    template<typename S> static void setHas(S&& s) { s.setHasTime(true); }
};
struct Est
{
    template<typename S> static auto get(S&& s) -> decltype(s.getEst()) { return s.getEst(); }
    template<typename S> static bool has(S&& s) { return s.hasEst(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setEst(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initEst(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantEst(); }
    template<typename S> static void setWant(S&& s) { s.setWantEst(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasEst(); }
    template<typename S> static void setHas(S&& s) { s.setHasEst(true); }
};
struct DesiredTarget
{
    template<typename S> static auto get(S&& s) -> decltype(s.getDesiredTarget()) { return s.getDesiredTarget(); }
    template<typename S> static bool has(S&& s) { return s.hasDesiredTarget(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setDesiredTarget(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initDesiredTarget(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantDesiredTarget(); }
    template<typename S> static void setWant(S&& s) { s.setWantDesiredTarget(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasDesiredTarget(); }
    template<typename S> static void setHas(S&& s) { s.setHasDesiredTarget(true); }
};
struct ReturnedTarget
{
    template<typename S> static auto get(S&& s) -> decltype(s.getReturnedTarget()) { return s.getReturnedTarget(); }
    template<typename S> static bool has(S&& s) { return s.hasReturnedTarget(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setReturnedTarget(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initReturnedTarget(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantReturnedTarget(); }
    template<typename S> static void setWant(S&& s) { s.setWantReturnedTarget(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasReturnedTarget(); }
    template<typename S> static void setHas(S&& s) { s.setHasReturnedTarget(true); }
};
struct Pass
{
    template<typename S> static auto get(S&& s) -> decltype(s.getPass()) { return s.getPass(); }
    template<typename S> static bool has(S&& s) { return s.hasPass(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setPass(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initPass(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantPass(); }
    template<typename S> static void setWant(S&& s) { s.setWantPass(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasPass(); }
    template<typename S> static void setHas(S&& s) { s.setHasPass(true); }
};
struct Fail
{
    template<typename S> static auto get(S&& s) -> decltype(s.getFail()) { return s.getFail(); }
    template<typename S> static bool has(S&& s) { return s.hasFail(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setFail(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initFail(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantFail(); }
    template<typename S> static void setWant(S&& s) { s.setWantFail(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasFail(); }
    template<typename S> static void setHas(S&& s) { s.setHasFail(true); }
};
struct Decay
{
    template<typename S> static auto get(S&& s) -> decltype(s.getDecay()) { return s.getDecay(); }
    template<typename S> static bool has(S&& s) { return s.hasDecay(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setDecay(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initDecay(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantDecay(); }
    template<typename S> static void setWant(S&& s) { s.setWantDecay(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasDecay(); }
    template<typename S> static void setHas(S&& s) { s.setHasDecay(true); }
};
struct Scale
{
    template<typename S> static auto get(S&& s) -> decltype(s.getScale()) { return s.getScale(); }
    template<typename S> static bool has(S&& s) { return s.hasScale(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setScale(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initScale(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantScale(); }
    template<typename S> static void setWant(S&& s) { s.setWantScale(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasScale(); }
    template<typename S> static void setHas(S&& s) { s.setHasScale(true); }
};
struct Start
{
    template<typename S> static auto get(S&& s) -> decltype(s.getStart()) { return s.getStart(); }
    template<typename S> static bool has(S&& s) { return s.hasStart(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setStart(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initStart(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantStart(); }
    template<typename S> static void setWant(S&& s) { s.setWantStart(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasStart(); }
    template<typename S> static void setHas(S&& s) { s.setHasStart(true); }
};
struct End
{
    template<typename S> static auto get(S&& s) -> decltype(s.getEnd()) { return s.getEnd(); }
    template<typename S> static bool has(S&& s) { return s.hasEnd(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setEnd(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initEnd(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantEnd(); }
    template<typename S> static void setWant(S&& s) { s.setWantEnd(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasEnd(); }
    template<typename S> static void setHas(S&& s) { s.setHasEnd(true); }
};
struct WithinTarget
{
    template<typename S> static auto get(S&& s) -> decltype(s.getWithinTarget()) { return s.getWithinTarget(); }
    template<typename S> static bool has(S&& s) { return s.hasWithinTarget(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setWithinTarget(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initWithinTarget(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantWithinTarget(); }
    template<typename S> static void setWant(S&& s) { s.setWantWithinTarget(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasWithinTarget(); }
    template<typename S> static void setHas(S&& s) { s.setHasWithinTarget(true); }
};
struct TotalConfirmed
{
    template<typename S> static auto get(S&& s) -> decltype(s.getTotalConfirmed()) { return s.getTotalConfirmed(); }
    template<typename S> static bool has(S&& s) { return s.hasTotalConfirmed(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setTotalConfirmed(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initTotalConfirmed(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantTotalConfirmed(); }
    template<typename S> static void setWant(S&& s) { s.setWantTotalConfirmed(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasTotalConfirmed(); }
    template<typename S> static void setHas(S&& s) { s.setHasTotalConfirmed(true); }
};
struct InMempool
{
    template<typename S> static auto get(S&& s) -> decltype(s.getInMempool()) { return s.getInMempool(); }
    template<typename S> static bool has(S&& s) { return s.hasInMempool(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setInMempool(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initInMempool(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantInMempool(); }
    template<typename S> static void setWant(S&& s) { s.setWantInMempool(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasInMempool(); }
    template<typename S> static void setHas(S&& s) { s.setHasInMempool(true); }
};
struct LeftMempool
{
    template<typename S> static auto get(S&& s) -> decltype(s.getLeftMempool()) { return s.getLeftMempool(); }
    template<typename S> static bool has(S&& s) { return s.hasLeftMempool(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setLeftMempool(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initLeftMempool(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantLeftMempool(); }
    template<typename S> static void setWant(S&& s) { s.setWantLeftMempool(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasLeftMempool(); }
    template<typename S> static void setHas(S&& s) { s.setHasLeftMempool(true); }
};
struct Category
{
    template<typename S> static auto get(S&& s) -> decltype(s.getCategory()) { return s.getCategory(); }
    template<typename S> static bool has(S&& s) { return s.hasCategory(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setCategory(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initCategory(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantCategory(); }
    template<typename S> static void setWant(S&& s) { s.setWantCategory(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasCategory(); }
    template<typename S> static void setHas(S&& s) { s.setHasCategory(true); }
};
struct Actor
{
    template<typename S> static auto get(S&& s) -> decltype(s.getActor()) { return s.getActor(); }
    template<typename S> static bool has(S&& s) { return s.hasActor(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setActor(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initActor(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantActor(); }
    template<typename S> static void setWant(S&& s) { s.setWantActor(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasActor(); }
    template<typename S> static void setHas(S&& s) { s.setHasActor(true); }
};
struct ArgNames
{
    template<typename S> static auto get(S&& s) -> decltype(s.getArgNames()) { return s.getArgNames(); }
    template<typename S> static bool has(S&& s) { return s.hasArgNames(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setArgNames(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initArgNames(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantArgNames(); }
    template<typename S> static void setWant(S&& s) { s.setWantArgNames(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasArgNames(); }
    template<typename S> static void setHas(S&& s) { s.setHasArgNames(true); }
};
struct UniqueId
{
    template<typename S> static auto get(S&& s) -> decltype(s.getUniqueId()) { return s.getUniqueId(); }
    template<typename S> static bool has(S&& s) { return s.hasUniqueId(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setUniqueId(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initUniqueId(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantUniqueId(); }
    template<typename S> static void setWant(S&& s) { s.setWantUniqueId(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasUniqueId(); }
    template<typename S> static void setHas(S&& s) { s.setHasUniqueId(true); }
};
struct NamedOnly
{
    template<typename S> static auto get(S&& s) -> decltype(s.getNamedOnly()) { return s.getNamedOnly(); }
    template<typename S> static bool has(S&& s) { return s.hasNamedOnly(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setNamedOnly(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initNamedOnly(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantNamedOnly(); }
    template<typename S> static void setWant(S&& s) { s.setWantNamedOnly(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasNamedOnly(); }
    template<typename S> static void setHas(S&& s) { s.setHasNamedOnly(true); }
};
struct Request
{
    template<typename S> static auto get(S&& s) -> decltype(s.getRequest()) { return s.getRequest(); }
    template<typename S> static bool has(S&& s) { return s.hasRequest(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setRequest(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initRequest(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantRequest(); }
    template<typename S> static void setWant(S&& s) { s.setWantRequest(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasRequest(); }
    template<typename S> static void setHas(S&& s) { s.setHasRequest(true); }
};
struct Response
{
    template<typename S> static auto get(S&& s) -> decltype(s.getResponse()) { return s.getResponse(); }
    template<typename S> static bool has(S&& s) { return s.hasResponse(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setResponse(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initResponse(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantResponse(); }
    template<typename S> static void setWant(S&& s) { s.setWantResponse(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasResponse(); }
    template<typename S> static void setHas(S&& s) { s.setHasResponse(true); }
};
struct LastCallback
{
    template<typename S> static auto get(S&& s) -> decltype(s.getLastCallback()) { return s.getLastCallback(); }
    template<typename S> static bool has(S&& s) { return s.hasLastCallback(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setLastCallback(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initLastCallback(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantLastCallback(); }
    template<typename S> static void setWant(S&& s) { s.setWantLastCallback(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasLastCallback(); }
    template<typename S> static void setHas(S&& s) { s.setHasLastCallback(true); }
};
struct RpcError
{
    template<typename S> static auto get(S&& s) -> decltype(s.getRpcError()) { return s.getRpcError(); }
    template<typename S> static bool has(S&& s) { return s.hasRpcError(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setRpcError(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initRpcError(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantRpcError(); }
    template<typename S> static void setWant(S&& s) { s.setWantRpcError(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasRpcError(); }
    template<typename S> static void setHas(S&& s) { s.setHasRpcError(true); }
};
struct TypeError
{
    template<typename S> static auto get(S&& s) -> decltype(s.getTypeError()) { return s.getTypeError(); }
    template<typename S> static bool has(S&& s) { return s.hasTypeError(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setTypeError(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initTypeError(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantTypeError(); }
    template<typename S> static void setWant(S&& s) { s.setWantTypeError(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasTypeError(); }
    template<typename S> static void setHas(S&& s) { s.setHasTypeError(true); }
};
struct Id
{
    template<typename S> static auto get(S&& s) -> decltype(s.getId()) { return s.getId(); }
    template<typename S> static bool has(S&& s) { return s.hasId(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setId(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initId(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantId(); }
    template<typename S> static void setWant(S&& s) { s.setWantId(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasId(); }
    template<typename S> static void setHas(S&& s) { s.setHasId(true); }
};
struct Params
{
    template<typename S> static auto get(S&& s) -> decltype(s.getParams()) { return s.getParams(); }
    template<typename S> static bool has(S&& s) { return s.hasParams(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setParams(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initParams(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantParams(); }
    template<typename S> static void setWant(S&& s) { s.setWantParams(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasParams(); }
    template<typename S> static void setHas(S&& s) { s.setHasParams(true); }
};
struct Mode
{
    template<typename S> static auto get(S&& s) -> decltype(s.getMode()) { return s.getMode(); }
    template<typename S> static bool has(S&& s) { return s.hasMode(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setMode(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initMode(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantMode(); }
    template<typename S> static void setWant(S&& s) { s.setWantMode(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasMode(); }
    template<typename S> static void setHas(S&& s) { s.setHasMode(true); }
};
struct Uri
{
    template<typename S> static auto get(S&& s) -> decltype(s.getUri()) { return s.getUri(); }
    template<typename S> static bool has(S&& s) { return s.hasUri(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setUri(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initUri(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantUri(); }
    template<typename S> static void setWant(S&& s) { s.setWantUri(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasUri(); }
    template<typename S> static void setHas(S&& s) { s.setHasUri(true); }
};
struct AuthUser
{
    template<typename S> static auto get(S&& s) -> decltype(s.getAuthUser()) { return s.getAuthUser(); }
    template<typename S> static bool has(S&& s) { return s.hasAuthUser(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setAuthUser(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initAuthUser(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantAuthUser(); }
    template<typename S> static void setWant(S&& s) { s.setWantAuthUser(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasAuthUser(); }
    template<typename S> static void setHas(S&& s) { s.setHasAuthUser(true); }
};
struct PeerAddr
{
    template<typename S> static auto get(S&& s) -> decltype(s.getPeerAddr()) { return s.getPeerAddr(); }
    template<typename S> static bool has(S&& s) { return s.hasPeerAddr(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setPeerAddr(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initPeerAddr(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantPeerAddr(); }
    template<typename S> static void setWant(S&& s) { s.setWantPeerAddr(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasPeerAddr(); }
    template<typename S> static void setHas(S&& s) { s.setHasPeerAddr(true); }
};
struct Version
{
    template<typename S> static auto get(S&& s) -> decltype(s.getVersion()) { return s.getVersion(); }
    template<typename S> static bool has(S&& s) { return s.hasVersion(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setVersion(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initVersion(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantVersion(); }
    template<typename S> static void setWant(S&& s) { s.setWantVersion(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasVersion(); }
    template<typename S> static void setHas(S&& s) { s.setHasVersion(true); }
};
struct WantHash
{
    template<typename S> static auto get(S&& s) -> decltype(s.getWantHash()) { return s.getWantHash(); }
    template<typename S> static bool has(S&& s) { return s.hasWantHash(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setWantHash(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initWantHash(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantWantHash(); }
    template<typename S> static void setWant(S&& s) { s.setWantWantHash(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasWantHash(); }
    template<typename S> static void setHas(S&& s) { s.setHasWantHash(true); }
};
struct WantHeight
{
    template<typename S> static auto get(S&& s) -> decltype(s.getWantHeight()) { return s.getWantHeight(); }
    template<typename S> static bool has(S&& s) { return s.hasWantHeight(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setWantHeight(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initWantHeight(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantWantHeight(); }
    template<typename S> static void setWant(S&& s) { s.setWantWantHeight(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasWantHeight(); }
    template<typename S> static void setHas(S&& s) { s.setHasWantHeight(true); }
};
struct WantTime
{
    template<typename S> static auto get(S&& s) -> decltype(s.getWantTime()) { return s.getWantTime(); }
    template<typename S> static bool has(S&& s) { return s.hasWantTime(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setWantTime(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initWantTime(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantWantTime(); }
    template<typename S> static void setWant(S&& s) { s.setWantWantTime(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasWantTime(); }
    template<typename S> static void setHas(S&& s) { s.setHasWantTime(true); }
};
struct WantMaxTime
{
    template<typename S> static auto get(S&& s) -> decltype(s.getWantMaxTime()) { return s.getWantMaxTime(); }
    template<typename S> static bool has(S&& s) { return s.hasWantMaxTime(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setWantMaxTime(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initWantMaxTime(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantWantMaxTime(); }
    template<typename S> static void setWant(S&& s) { s.setWantWantMaxTime(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasWantMaxTime(); }
    template<typename S> static void setHas(S&& s) { s.setHasWantMaxTime(true); }
};
struct WantMtpTime
{
    template<typename S> static auto get(S&& s) -> decltype(s.getWantMtpTime()) { return s.getWantMtpTime(); }
    template<typename S> static bool has(S&& s) { return s.hasWantMtpTime(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setWantMtpTime(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initWantMtpTime(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantWantMtpTime(); }
    template<typename S> static void setWant(S&& s) { s.setWantWantMtpTime(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasWantMtpTime(); }
    template<typename S> static void setHas(S&& s) { s.setHasWantMtpTime(true); }
};
struct WantInActiveChain
{
    template<typename S> static auto get(S&& s) -> decltype(s.getWantInActiveChain()) { return s.getWantInActiveChain(); }
    template<typename S> static bool has(S&& s) { return s.hasWantInActiveChain(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setWantInActiveChain(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initWantInActiveChain(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantWantInActiveChain(); }
    template<typename S> static void setWant(S&& s) { s.setWantWantInActiveChain(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasWantInActiveChain(); }
    template<typename S> static void setHas(S&& s) { s.setHasWantInActiveChain(true); }
};
struct WantLocator
{
    template<typename S> static auto get(S&& s) -> decltype(s.getWantLocator()) { return s.getWantLocator(); }
    template<typename S> static bool has(S&& s) { return s.hasWantLocator(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setWantLocator(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initWantLocator(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantWantLocator(); }
    template<typename S> static void setWant(S&& s) { s.setWantWantLocator(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasWantLocator(); }
    template<typename S> static void setHas(S&& s) { s.setHasWantLocator(true); }
};
struct NextBlock
{
    template<typename S> static auto get(S&& s) -> decltype(s.getNextBlock()) { return s.getNextBlock(); }
    template<typename S> static bool has(S&& s) { return s.hasNextBlock(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setNextBlock(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initNextBlock(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantNextBlock(); }
    template<typename S> static void setWant(S&& s) { s.setWantNextBlock(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasNextBlock(); }
    template<typename S> static void setHas(S&& s) { s.setHasNextBlock(true); }
};
struct WantData
{
    template<typename S> static auto get(S&& s) -> decltype(s.getWantData()) { return s.getWantData(); }
    template<typename S> static bool has(S&& s) { return s.hasWantData(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setWantData(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initWantData(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantWantData(); }
    template<typename S> static void setWant(S&& s) { s.setWantWantData(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasWantData(); }
    template<typename S> static void setHas(S&& s) { s.setHasWantData(true); }
};
struct MaxTime
{
    template<typename S> static auto get(S&& s) -> decltype(s.getMaxTime()) { return s.getMaxTime(); }
    template<typename S> static bool has(S&& s) { return s.hasMaxTime(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setMaxTime(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initMaxTime(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantMaxTime(); }
    template<typename S> static void setWant(S&& s) { s.setWantMaxTime(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasMaxTime(); }
    template<typename S> static void setHas(S&& s) { s.setHasMaxTime(true); }
};
struct MtpTime
{
    template<typename S> static auto get(S&& s) -> decltype(s.getMtpTime()) { return s.getMtpTime(); }
    template<typename S> static bool has(S&& s) { return s.hasMtpTime(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setMtpTime(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initMtpTime(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantMtpTime(); }
    template<typename S> static void setWant(S&& s) { s.setWantMtpTime(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasMtpTime(); }
    template<typename S> static void setHas(S&& s) { s.setHasMtpTime(true); }
};
struct InActiveChain
{
    template<typename S> static auto get(S&& s) -> decltype(s.getInActiveChain()) { return s.getInActiveChain(); }
    template<typename S> static bool has(S&& s) { return s.hasInActiveChain(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setInActiveChain(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initInActiveChain(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantInActiveChain(); }
    template<typename S> static void setWant(S&& s) { s.setWantInActiveChain(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasInActiveChain(); }
    template<typename S> static void setHas(S&& s) { s.setHasInActiveChain(true); }
};
struct Data
{
    template<typename S> static auto get(S&& s) -> decltype(s.getData()) { return s.getData(); }
    template<typename S> static bool has(S&& s) { return s.hasData(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setData(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initData(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantData(); }
    template<typename S> static void setWant(S&& s) { s.setWantData(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasData(); }
    template<typename S> static void setHas(S&& s) { s.setHasData(true); }
};
struct Found
{
    template<typename S> static auto get(S&& s) -> decltype(s.getFound()) { return s.getFound(); }
    template<typename S> static bool has(S&& s) { return s.hasFound(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setFound(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initFound(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantFound(); }
    template<typename S> static void setWant(S&& s) { s.setWantFound(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasFound(); }
    template<typename S> static void setHas(S&& s) { s.setHasFound(true); }
};
struct PrevHash
{
    template<typename S> static auto get(S&& s) -> decltype(s.getPrevHash()) { return s.getPrevHash(); }
    template<typename S> static bool has(S&& s) { return s.hasPrevHash(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setPrevHash(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initPrevHash(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantPrevHash(); }
    template<typename S> static void setWant(S&& s) { s.setWantPrevHash(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasPrevHash(); }
    template<typename S> static void setHas(S&& s) { s.setHasPrevHash(true); }
};
struct FileNumber
{
    template<typename S> static auto get(S&& s) -> decltype(s.getFileNumber()) { return s.getFileNumber(); }
    template<typename S> static bool has(S&& s) { return s.hasFileNumber(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setFileNumber(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initFileNumber(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantFileNumber(); }
    template<typename S> static void setWant(S&& s) { s.setWantFileNumber(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasFileNumber(); }
    template<typename S> static void setHas(S&& s) { s.setHasFileNumber(true); }
};
struct DataPos
{
    template<typename S> static auto get(S&& s) -> decltype(s.getDataPos()) { return s.getDataPos(); }
    template<typename S> static bool has(S&& s) { return s.hasDataPos(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setDataPos(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initDataPos(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantDataPos(); }
    template<typename S> static void setWant(S&& s) { s.setWantDataPos(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasDataPos(); }
    template<typename S> static void setHas(S&& s) { s.setHasDataPos(true); }
};
struct UndoData
{
    template<typename S> static auto get(S&& s) -> decltype(s.getUndoData()) { return s.getUndoData(); }
    template<typename S> static bool has(S&& s) { return s.hasUndoData(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setUndoData(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initUndoData(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantUndoData(); }
    template<typename S> static void setWant(S&& s) { s.setWantUndoData(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasUndoData(); }
    template<typename S> static void setHas(S&& s) { s.setHasUndoData(true); }
};
struct ChainTimeMax
{
    template<typename S> static auto get(S&& s) -> decltype(s.getChainTimeMax()) { return s.getChainTimeMax(); }
    template<typename S> static bool has(S&& s) { return s.hasChainTimeMax(); }
    template<typename S, typename A> static void set(S&& s, A&& a) { s.setChainTimeMax(std::forward<A>(a)); }
    template<typename S, typename... A> static decltype(auto) init(S&& s, A&&... a) { return s.initChainTimeMax(std::forward<A>(a)...); }
    template<typename S> static bool getWant(S&& s) { return s.getWantChainTimeMax(); }
    template<typename S> static void setWant(S&& s) { s.setWantChainTimeMax(true); }
    template<typename S> static bool getHas(S&& s) { return s.getHasChainTimeMax(); }
    template<typename S> static void setHas(S&& s) { s.setHasChainTimeMax(true); }
};
} // namespace chain_fields

template<>
struct ProxyClient<ipc::capnp::messages::Chain> final : public ProxyClientCustom<ipc::capnp::messages::Chain, interfaces::Chain>
{
public:
    using ProxyClientCustom::ProxyClientCustom;
    ~ProxyClient();
    using M0 = ProxyClientMethodTraits<ipc::capnp::messages::Chain::DestroyParams>;
    static typename M0::Result destroy(Super& super);
    using M1 = ProxyClientMethodTraits<ipc::capnp::messages::Chain::GetHeightParams>;
    typename M1::Result getHeight();
    using M2 = ProxyClientMethodTraits<ipc::capnp::messages::Chain::GetBlockHashParams>;
    typename M2::Result getBlockHash(M2::Param<0> height);
    using M3 = ProxyClientMethodTraits<ipc::capnp::messages::Chain::HaveBlockOnDiskParams>;
    typename M3::Result haveBlockOnDisk(M3::Param<0> height);
    using M4 = ProxyClientMethodTraits<ipc::capnp::messages::Chain::GetTipLocatorParams>;
    typename M4::Result getTipLocator();
    using M5 = ProxyClientMethodTraits<ipc::capnp::messages::Chain::GetActiveChainLocatorParams>;
    typename M5::Result getActiveChainLocator(M5::Param<0> blockHash);
    using M6 = ProxyClientMethodTraits<ipc::capnp::messages::Chain::FindLocatorForkParams>;
    typename M6::Result findLocatorFork(M6::Param<0> locator);
    using M7 = ProxyClientMethodTraits<ipc::capnp::messages::Chain::HasBlockFilterIndexParams>;
    typename M7::Result hasBlockFilterIndex(M7::Param<0> filterType);
    using M8 = ProxyClientMethodTraits<ipc::capnp::messages::Chain::BlockFilterMatchesAnyParams>;
    typename M8::Result blockFilterMatchesAny(M8::Param<0> filterType,M8::Param<1> blockHash,M8::Param<2> filterSet);
    using M9 = ProxyClientMethodTraits<ipc::capnp::messages::Chain::FindBlockParams>;
    typename M9::Result findBlock(M9::Param<0> hash,M9::Param<1> block);
    using M10 = ProxyClientMethodTraits<ipc::capnp::messages::Chain::FindFirstBlockWithTimeAndHeightParams>;
    typename M10::Result findFirstBlockWithTimeAndHeight(M10::Param<0> minTime,M10::Param<1> minHeight,M10::Param<2> block);
    using M11 = ProxyClientMethodTraits<ipc::capnp::messages::Chain::FindAncestorByHeightParams>;
    typename M11::Result findAncestorByHeight(M11::Param<0> blockHash,M11::Param<1> ancestorHeight,M11::Param<2> ancestor);
    using M12 = ProxyClientMethodTraits<ipc::capnp::messages::Chain::FindAncestorByHashParams>;
    typename M12::Result findAncestorByHash(M12::Param<0> blockHash,M12::Param<1> ancestorHash,M12::Param<2> ancestor);
    using M13 = ProxyClientMethodTraits<ipc::capnp::messages::Chain::FindCommonAncestorParams>;
    typename M13::Result findCommonAncestor(M13::Param<0> blockHash1,M13::Param<1> blockHash2,M13::Param<2> ancestor,M13::Param<3> block1,M13::Param<4> block2);
    using M14 = ProxyClientMethodTraits<ipc::capnp::messages::Chain::FindCoinsParams>;
    typename M14::Result findCoins(M14::Param<0> coins);
    using M15 = ProxyClientMethodTraits<ipc::capnp::messages::Chain::GuessVerificationProgressParams>;
    typename M15::Result guessVerificationProgress(M15::Param<0> blockHash);
    using M16 = ProxyClientMethodTraits<ipc::capnp::messages::Chain::HasBlocksParams>;
    typename M16::Result hasBlocks(M16::Param<0> blockHash,M16::Param<1> minHeight,M16::Param<2> maxHeight);
    using M17 = ProxyClientMethodTraits<ipc::capnp::messages::Chain::IsRBFOptInParams>;
    typename M17::Result isRBFOptIn(M17::Param<0> tx);
    using M18 = ProxyClientMethodTraits<ipc::capnp::messages::Chain::IsInMempoolParams>;
    typename M18::Result isInMempool(M18::Param<0> txid);
    using M19 = ProxyClientMethodTraits<ipc::capnp::messages::Chain::HasDescendantsInMempoolParams>;
    typename M19::Result hasDescendantsInMempool(M19::Param<0> txid);
    using M20 = ProxyClientMethodTraits<ipc::capnp::messages::Chain::BroadcastTransactionParams>;
    typename M20::Result broadcastTransaction(M20::Param<0> tx,M20::Param<1> maxTxFee,M20::Param<2> relay,M20::Param<3> error);
    using M21 = ProxyClientMethodTraits<ipc::capnp::messages::Chain::GetTransactionAncestryParams>;
    typename M21::Result getTransactionAncestry(M21::Param<0> txid,M21::Param<1> ancestors,M21::Param<2> descendants,M21::Param<3> ancestorsize,M21::Param<4> ancestorfees);
    using M22 = ProxyClientMethodTraits<ipc::capnp::messages::Chain::CalculateIndividualBumpFeesParams>;
    typename M22::Result calculateIndividualBumpFees(M22::Param<0> outpoints,M22::Param<1> targetFeerate);
    using M23 = ProxyClientMethodTraits<ipc::capnp::messages::Chain::CalculateCombinedBumpFeeParams>;
    typename M23::Result calculateCombinedBumpFee(M23::Param<0> outpoints,M23::Param<1> targetFeerate);
    using M24 = ProxyClientMethodTraits<ipc::capnp::messages::Chain::GetPackageLimitsParams>;
    typename M24::Result getPackageLimits(M24::Param<0> ancestors,M24::Param<1> descendants);
    using M25 = ProxyClientMethodTraits<ipc::capnp::messages::Chain::CheckChainLimitsParams>;
    typename M25::Result checkChainLimits(M25::Param<0> tx);
    using M26 = ProxyClientMethodTraits<ipc::capnp::messages::Chain::EstimateSmartFeeParams>;
    typename M26::Result estimateSmartFee(M26::Param<0> numBlocks,M26::Param<1> conservative,M26::Param<2> calc);
    using M27 = ProxyClientMethodTraits<ipc::capnp::messages::Chain::EstimateMaxBlocksParams>;
    typename M27::Result estimateMaxBlocks();
    using M28 = ProxyClientMethodTraits<ipc::capnp::messages::Chain::MempoolMinFeeParams>;
    typename M28::Result mempoolMinFee();
    using M29 = ProxyClientMethodTraits<ipc::capnp::messages::Chain::RelayMinFeeParams>;
    typename M29::Result relayMinFee();
    using M30 = ProxyClientMethodTraits<ipc::capnp::messages::Chain::RelayIncrementalFeeParams>;
    typename M30::Result relayIncrementalFee();
    using M31 = ProxyClientMethodTraits<ipc::capnp::messages::Chain::RelayDustFeeParams>;
    typename M31::Result relayDustFee();
    using M32 = ProxyClientMethodTraits<ipc::capnp::messages::Chain::HavePrunedParams>;
    typename M32::Result havePruned();
    using M33 = ProxyClientMethodTraits<ipc::capnp::messages::Chain::GetPruneHeightParams>;
    typename M33::Result getPruneHeight();
    using M34 = ProxyClientMethodTraits<ipc::capnp::messages::Chain::IsReadyToBroadcastParams>;
    typename M34::Result isReadyToBroadcast();
    using M35 = ProxyClientMethodTraits<ipc::capnp::messages::Chain::IsInitialBlockDownloadParams>;
    typename M35::Result isInitialBlockDownload();
    using M36 = ProxyClientMethodTraits<ipc::capnp::messages::Chain::ShutdownRequestedParams>;
    typename M36::Result shutdownRequested();
    using M37 = ProxyClientMethodTraits<ipc::capnp::messages::Chain::InitMessageParams>;
    typename M37::Result initMessage(M37::Param<0> message);
    using M38 = ProxyClientMethodTraits<ipc::capnp::messages::Chain::InitWarningParams>;
    typename M38::Result initWarning(M38::Param<0> message);
    using M39 = ProxyClientMethodTraits<ipc::capnp::messages::Chain::InitErrorParams>;
    typename M39::Result initError(M39::Param<0> message);
    using M40 = ProxyClientMethodTraits<ipc::capnp::messages::Chain::ShowProgressParams>;
    typename M40::Result showProgress(M40::Param<0> title,M40::Param<1> progress,M40::Param<2> resumePossible);
    using M41 = ProxyClientMethodTraits<ipc::capnp::messages::Chain::HandleNotificationsParams>;
    typename M41::Result handleNotifications(M41::Param<0> notifications);
    using M42 = ProxyClientMethodTraits<ipc::capnp::messages::Chain::WaitForNotificationsIfTipChangedParams>;
    typename M42::Result waitForNotificationsIfTipChanged(M42::Param<0> oldTip);
    using M43 = ProxyClientMethodTraits<ipc::capnp::messages::Chain::HandleRpcParams>;
    typename M43::Result handleRpc(M43::Param<0> command);
    using M44 = ProxyClientMethodTraits<ipc::capnp::messages::Chain::RpcEnableDeprecatedParams>;
    typename M44::Result rpcEnableDeprecated(M44::Param<0> method);
    using M45 = ProxyClientMethodTraits<ipc::capnp::messages::Chain::RpcRunLaterParams>;
    typename M45::Result rpcRunLater(M45::Param<0> name,M45::Param<1> fn,M45::Param<2> seconds);
    using M46 = ProxyClientMethodTraits<ipc::capnp::messages::Chain::GetSettingParams>;
    typename M46::Result getSetting(M46::Param<0> name);
    using M47 = ProxyClientMethodTraits<ipc::capnp::messages::Chain::GetSettingsListParams>;
    typename M47::Result getSettingsList(M47::Param<0> name);
    using M48 = ProxyClientMethodTraits<ipc::capnp::messages::Chain::GetRwSettingParams>;
    typename M48::Result getRwSetting(M48::Param<0> name);
    using M49 = ProxyClientMethodTraits<ipc::capnp::messages::Chain::UpdateRwSettingParams>;
    typename M49::Result updateRwSetting(M49::Param<0> name,M49::Param<1> update);
    using M50 = ProxyClientMethodTraits<ipc::capnp::messages::Chain::OverwriteRwSettingParams>;
    typename M50::Result overwriteRwSetting(M50::Param<0> name,M50::Param<1> value,M50::Param<2> action);
    using M51 = ProxyClientMethodTraits<ipc::capnp::messages::Chain::DeleteRwSettingsParams>;
    typename M51::Result deleteRwSettings(M51::Param<0> name,M51::Param<1> action);
    using M52 = ProxyClientMethodTraits<ipc::capnp::messages::Chain::RequestMempoolTransactionsParams>;
    typename M52::Result requestMempoolTransactions(M52::Param<0> notifications);
    using M53 = ProxyClientMethodTraits<ipc::capnp::messages::Chain::HasAssumedValidChainParams>;
    typename M53::Result hasAssumedValidChain();
};

template<>
struct ProxyServer<ipc::capnp::messages::Chain> : public ProxyServerCustom<ipc::capnp::messages::Chain, interfaces::Chain>
{
public:
    using ProxyServerCustom::ProxyServerCustom;
    ~ProxyServer();
    kj::Promise<void> destroy(DestroyContext call_context) override;
    kj::Promise<void> getHeight(GetHeightContext call_context) override;
    kj::Promise<void> getBlockHash(GetBlockHashContext call_context) override;
    kj::Promise<void> haveBlockOnDisk(HaveBlockOnDiskContext call_context) override;
    kj::Promise<void> getTipLocator(GetTipLocatorContext call_context) override;
    kj::Promise<void> getActiveChainLocator(GetActiveChainLocatorContext call_context) override;
    kj::Promise<void> findLocatorFork(FindLocatorForkContext call_context) override;
    kj::Promise<void> hasBlockFilterIndex(HasBlockFilterIndexContext call_context) override;
    kj::Promise<void> blockFilterMatchesAny(BlockFilterMatchesAnyContext call_context) override;
    kj::Promise<void> findBlock(FindBlockContext call_context) override;
    kj::Promise<void> findFirstBlockWithTimeAndHeight(FindFirstBlockWithTimeAndHeightContext call_context) override;
    kj::Promise<void> findAncestorByHeight(FindAncestorByHeightContext call_context) override;
    kj::Promise<void> findAncestorByHash(FindAncestorByHashContext call_context) override;
    kj::Promise<void> findCommonAncestor(FindCommonAncestorContext call_context) override;
    kj::Promise<void> findCoins(FindCoinsContext call_context) override;
    kj::Promise<void> guessVerificationProgress(GuessVerificationProgressContext call_context) override;
    kj::Promise<void> hasBlocks(HasBlocksContext call_context) override;
    kj::Promise<void> isRBFOptIn(IsRBFOptInContext call_context) override;
    kj::Promise<void> isInMempool(IsInMempoolContext call_context) override;
    kj::Promise<void> hasDescendantsInMempool(HasDescendantsInMempoolContext call_context) override;
    kj::Promise<void> broadcastTransaction(BroadcastTransactionContext call_context) override;
    kj::Promise<void> getTransactionAncestry(GetTransactionAncestryContext call_context) override;
    kj::Promise<void> calculateIndividualBumpFees(CalculateIndividualBumpFeesContext call_context) override;
    kj::Promise<void> calculateCombinedBumpFee(CalculateCombinedBumpFeeContext call_context) override;
    kj::Promise<void> getPackageLimits(GetPackageLimitsContext call_context) override;
    kj::Promise<void> checkChainLimits(CheckChainLimitsContext call_context) override;
    kj::Promise<void> estimateSmartFee(EstimateSmartFeeContext call_context) override;
    kj::Promise<void> estimateMaxBlocks(EstimateMaxBlocksContext call_context) override;
    kj::Promise<void> mempoolMinFee(MempoolMinFeeContext call_context) override;
    kj::Promise<void> relayMinFee(RelayMinFeeContext call_context) override;
    kj::Promise<void> relayIncrementalFee(RelayIncrementalFeeContext call_context) override;
    kj::Promise<void> relayDustFee(RelayDustFeeContext call_context) override;
    kj::Promise<void> havePruned(HavePrunedContext call_context) override;
    kj::Promise<void> getPruneHeight(GetPruneHeightContext call_context) override;
    kj::Promise<void> isReadyToBroadcast(IsReadyToBroadcastContext call_context) override;
    kj::Promise<void> isInitialBlockDownload(IsInitialBlockDownloadContext call_context) override;
    kj::Promise<void> shutdownRequested(ShutdownRequestedContext call_context) override;
    kj::Promise<void> initMessage(InitMessageContext call_context) override;
    kj::Promise<void> initWarning(InitWarningContext call_context) override;
    kj::Promise<void> initError(InitErrorContext call_context) override;
    kj::Promise<void> showProgress(ShowProgressContext call_context) override;
    kj::Promise<void> handleNotifications(HandleNotificationsContext call_context) override;
    kj::Promise<void> waitForNotificationsIfTipChanged(WaitForNotificationsIfTipChangedContext call_context) override;
    kj::Promise<void> handleRpc(HandleRpcContext call_context) override;
    kj::Promise<void> rpcEnableDeprecated(RpcEnableDeprecatedContext call_context) override;
    kj::Promise<void> rpcRunLater(RpcRunLaterContext call_context) override;
    kj::Promise<void> getSetting(GetSettingContext call_context) override;
    kj::Promise<void> getSettingsList(GetSettingsListContext call_context) override;
    kj::Promise<void> getRwSetting(GetRwSettingContext call_context) override;
    kj::Promise<void> updateRwSetting(UpdateRwSettingContext call_context) override;
    kj::Promise<void> overwriteRwSetting(OverwriteRwSettingContext call_context) override;
    kj::Promise<void> deleteRwSettings(DeleteRwSettingsContext call_context) override;
    kj::Promise<void> requestMempoolTransactions(RequestMempoolTransactionsContext call_context) override;
    kj::Promise<void> hasAssumedValidChain(HasAssumedValidChainContext call_context) override;
};

template<>
struct ProxyType<interfaces::Chain>
{
    using Type = interfaces::Chain;
    using Message = ipc::capnp::messages::Chain;
    using Client = ProxyClient<Message>;
    using Server = ProxyServer<Message>;
};

template<>
struct ProxyClient<ipc::capnp::messages::ChainNotifications> final : public ProxyClientCustom<ipc::capnp::messages::ChainNotifications, interfaces::Chain::Notifications>
{
public:
    using ProxyClientCustom::ProxyClientCustom;
    ~ProxyClient();
    using M0 = ProxyClientMethodTraits<ipc::capnp::messages::ChainNotifications::DestroyParams>;
    static typename M0::Result destroy(Super& super);
    using M1 = ProxyClientMethodTraits<ipc::capnp::messages::ChainNotifications::TransactionAddedToMempoolParams>;
    typename M1::Result transactionAddedToMempool(M1::Param<0> tx);
    using M2 = ProxyClientMethodTraits<ipc::capnp::messages::ChainNotifications::TransactionRemovedFromMempoolParams>;
    typename M2::Result transactionRemovedFromMempool(M2::Param<0> tx,M2::Param<1> reason);
    using M3 = ProxyClientMethodTraits<ipc::capnp::messages::ChainNotifications::BlockConnectedParams>;
    typename M3::Result blockConnected(M3::Param<0> role,M3::Param<1> block);
    using M4 = ProxyClientMethodTraits<ipc::capnp::messages::ChainNotifications::BlockDisconnectedParams>;
    typename M4::Result blockDisconnected(M4::Param<0> block);
    using M5 = ProxyClientMethodTraits<ipc::capnp::messages::ChainNotifications::UpdatedBlockTipParams>;
    typename M5::Result updatedBlockTip();
    using M6 = ProxyClientMethodTraits<ipc::capnp::messages::ChainNotifications::ChainStateFlushedParams>;
    typename M6::Result chainStateFlushed(M6::Param<0> role,M6::Param<1> locator);
};

template<>
struct ProxyServer<ipc::capnp::messages::ChainNotifications> : public ProxyServerCustom<ipc::capnp::messages::ChainNotifications, interfaces::Chain::Notifications>
{
public:
    using ProxyServerCustom::ProxyServerCustom;
    ~ProxyServer();
    kj::Promise<void> destroy(DestroyContext call_context) override;
    kj::Promise<void> transactionAddedToMempool(TransactionAddedToMempoolContext call_context) override;
    kj::Promise<void> transactionRemovedFromMempool(TransactionRemovedFromMempoolContext call_context) override;
    kj::Promise<void> blockConnected(BlockConnectedContext call_context) override;
    kj::Promise<void> blockDisconnected(BlockDisconnectedContext call_context) override;
    kj::Promise<void> updatedBlockTip(UpdatedBlockTipContext call_context) override;
    kj::Promise<void> chainStateFlushed(ChainStateFlushedContext call_context) override;
};

template<>
struct ProxyType<interfaces::Chain::Notifications>
{
    using Type = interfaces::Chain::Notifications;
    using Message = ipc::capnp::messages::ChainNotifications;
    using Client = ProxyClient<Message>;
    using Server = ProxyServer<Message>;
};

template<>
struct ProxyClient<ipc::capnp::messages::ChainClient> final : public ProxyClientCustom<ipc::capnp::messages::ChainClient, interfaces::ChainClient>
{
public:
    using ProxyClientCustom::ProxyClientCustom;
    ~ProxyClient();
    using M0 = ProxyClientMethodTraits<ipc::capnp::messages::ChainClient::DestroyParams>;
    static typename M0::Result destroy(Super& super);
    using M1 = ProxyClientMethodTraits<ipc::capnp::messages::ChainClient::RegisterRpcsParams>;
    typename M1::Result registerRpcs();
    using M2 = ProxyClientMethodTraits<ipc::capnp::messages::ChainClient::VerifyParams>;
    typename M2::Result verify();
    using M3 = ProxyClientMethodTraits<ipc::capnp::messages::ChainClient::LoadParams>;
    typename M3::Result load();
    using M4 = ProxyClientMethodTraits<ipc::capnp::messages::ChainClient::StartParams>;
    typename M4::Result start(M4::Param<0> scheduler);
    using M5 = ProxyClientMethodTraits<ipc::capnp::messages::ChainClient::FlushParams>;
    typename M5::Result flush();
    using M6 = ProxyClientMethodTraits<ipc::capnp::messages::ChainClient::StopParams>;
    typename M6::Result stop();
    using M7 = ProxyClientMethodTraits<ipc::capnp::messages::ChainClient::SetMockTimeParams>;
    typename M7::Result setMockTime(M7::Param<0> time);
    using M8 = ProxyClientMethodTraits<ipc::capnp::messages::ChainClient::SchedulerMockForwardParams>;
    typename M8::Result schedulerMockForward(M8::Param<0> time);
};

template<>
struct ProxyServer<ipc::capnp::messages::ChainClient> : public ProxyServerCustom<ipc::capnp::messages::ChainClient, interfaces::ChainClient>
{
public:
    using ProxyServerCustom::ProxyServerCustom;
    ~ProxyServer();
    kj::Promise<void> destroy(DestroyContext call_context) override;
    kj::Promise<void> registerRpcs(RegisterRpcsContext call_context) override;
    kj::Promise<void> verify(VerifyContext call_context) override;
    kj::Promise<void> load(LoadContext call_context) override;
    kj::Promise<void> start(StartContext call_context) override;
    kj::Promise<void> flush(FlushContext call_context) override;
    kj::Promise<void> stop(StopContext call_context) override;
    kj::Promise<void> setMockTime(SetMockTimeContext call_context) override;
    kj::Promise<void> schedulerMockForward(SchedulerMockForwardContext call_context) override;
};

template<>
struct ProxyType<interfaces::ChainClient>
{
    using Type = interfaces::ChainClient;
    using Message = ipc::capnp::messages::ChainClient;
    using Client = ProxyClient<Message>;
    using Server = ProxyServer<Message>;
};
template<>
struct ProxyStruct<ipc::capnp::messages::FeeCalculation>
{
    using Struct = ipc::capnp::messages::FeeCalculation;
    using EstAccessor = Accessor<chain_fields::Est, FIELD_IN | FIELD_OUT | FIELD_BOXED>;
    using ReasonAccessor = Accessor<chain_fields::Reason, FIELD_IN | FIELD_OUT>;
    using DesiredTargetAccessor = Accessor<chain_fields::DesiredTarget, FIELD_IN | FIELD_OUT>;
    using ReturnedTargetAccessor = Accessor<chain_fields::ReturnedTarget, FIELD_IN | FIELD_OUT>;
    using Accessors = std::tuple<EstAccessor, ReasonAccessor, DesiredTargetAccessor, ReturnedTargetAccessor>;
    static constexpr size_t fields = 4;
};
template<>
struct ProxyStruct<ipc::capnp::messages::EstimationResult>
{
    using Struct = ipc::capnp::messages::EstimationResult;
    using PassAccessor = Accessor<chain_fields::Pass, FIELD_IN | FIELD_OUT | FIELD_BOXED>;
    using FailAccessor = Accessor<chain_fields::Fail, FIELD_IN | FIELD_OUT | FIELD_BOXED>;
    using DecayAccessor = Accessor<chain_fields::Decay, FIELD_IN | FIELD_OUT>;
    using ScaleAccessor = Accessor<chain_fields::Scale, FIELD_IN | FIELD_OUT>;
    using Accessors = std::tuple<PassAccessor, FailAccessor, DecayAccessor, ScaleAccessor>;
    static constexpr size_t fields = 4;
};
template<>
struct ProxyStruct<ipc::capnp::messages::EstimatorBucket>
{
    using Struct = ipc::capnp::messages::EstimatorBucket;
    using StartAccessor = Accessor<chain_fields::Start, FIELD_IN | FIELD_OUT>;
    using EndAccessor = Accessor<chain_fields::End, FIELD_IN | FIELD_OUT>;
    using WithinTargetAccessor = Accessor<chain_fields::WithinTarget, FIELD_IN | FIELD_OUT>;
    using TotalConfirmedAccessor = Accessor<chain_fields::TotalConfirmed, FIELD_IN | FIELD_OUT>;
    using InMempoolAccessor = Accessor<chain_fields::InMempool, FIELD_IN | FIELD_OUT>;
    using LeftMempoolAccessor = Accessor<chain_fields::LeftMempool, FIELD_IN | FIELD_OUT>;
    using Accessors = std::tuple<StartAccessor, EndAccessor, WithinTargetAccessor, TotalConfirmedAccessor, InMempoolAccessor, LeftMempoolAccessor>;
    static constexpr size_t fields = 6;
};
template<>
struct ProxyStruct<ipc::capnp::messages::RPCCommand>
{
    using Struct = ipc::capnp::messages::RPCCommand;
    using CategoryAccessor = Accessor<chain_fields::Category, FIELD_IN | FIELD_OUT | FIELD_BOXED>;
    using NameAccessor = Accessor<chain_fields::Name, FIELD_IN | FIELD_OUT | FIELD_BOXED>;
    using ActorAccessor = Accessor<chain_fields::Actor, FIELD_IN | FIELD_OUT | FIELD_BOXED>;
    using ArgNamesAccessor = Accessor<chain_fields::ArgNames, FIELD_IN | FIELD_OUT | FIELD_BOXED>;
    using UniqueIdAccessor = Accessor<chain_fields::UniqueId, FIELD_IN | FIELD_OUT>;
    using Accessors = std::tuple<CategoryAccessor, NameAccessor, ActorAccessor, ArgNamesAccessor, UniqueIdAccessor>;
    static constexpr size_t fields = 5;
};
template<>
struct ProxyStruct<ipc::capnp::messages::RPCArg>
{
    using Struct = ipc::capnp::messages::RPCArg;
    using NameAccessor = Accessor<chain_fields::Name, FIELD_IN | FIELD_OUT | FIELD_BOXED>;
    using NamedOnlyAccessor = Accessor<chain_fields::NamedOnly, FIELD_IN | FIELD_OUT>;
    using Accessors = std::tuple<NameAccessor, NamedOnlyAccessor>;
    static constexpr size_t fields = 2;
};

template<>
struct ProxyClient<ipc::capnp::messages::ActorCallback> final : public ProxyClientCustom<ipc::capnp::messages::ActorCallback, ProxyCallback<CRPCCommand::Actor>>
{
public:
    using ProxyClientCustom::ProxyClientCustom;
    ~ProxyClient();
    using M0 = ProxyClientMethodTraits<ipc::capnp::messages::ActorCallback::CallParams>;
    typename M0::Result call(M0::Param<0> request,M0::Param<1> response,M0::Param<2> lastCallback);
};

template<>
struct ProxyServer<ipc::capnp::messages::ActorCallback> : public ProxyServerCustom<ipc::capnp::messages::ActorCallback, ProxyCallback<CRPCCommand::Actor>>
{
public:
    using ProxyServerCustom::ProxyServerCustom;
    ~ProxyServer();
    kj::Promise<void> call(CallContext call_context) override;
};

template<>
struct ProxyStruct<ipc::capnp::messages::JSONRPCRequest>
{
    using Struct = ipc::capnp::messages::JSONRPCRequest;
    using IdAccessor = Accessor<chain_fields::Id, FIELD_IN | FIELD_OUT | FIELD_BOXED>;
    using MethodAccessor = Accessor<chain_fields::Method, FIELD_IN | FIELD_OUT | FIELD_BOXED>;
    using ParamsAccessor = Accessor<chain_fields::Params, FIELD_IN | FIELD_OUT | FIELD_BOXED>;
    using ModeAccessor = Accessor<chain_fields::Mode, FIELD_IN | FIELD_OUT>;
    using UriAccessor = Accessor<chain_fields::Uri, FIELD_IN | FIELD_OUT | FIELD_BOXED>;
    using AuthUserAccessor = Accessor<chain_fields::AuthUser, FIELD_IN | FIELD_OUT | FIELD_BOXED>;
    using PeerAddrAccessor = Accessor<chain_fields::PeerAddr, FIELD_IN | FIELD_OUT | FIELD_BOXED>;
    using VersionAccessor = Accessor<chain_fields::Version, FIELD_IN | FIELD_OUT>;
    using Accessors = std::tuple<IdAccessor, MethodAccessor, ParamsAccessor, ModeAccessor, UriAccessor, AuthUserAccessor, PeerAddrAccessor, VersionAccessor>;
    static constexpr size_t fields = 8;
};

template<>
struct ProxyClient<ipc::capnp::messages::RunLaterCallback> final : public ProxyClientCustom<ipc::capnp::messages::RunLaterCallback, ProxyCallback<std::function<void()>>>
{
public:
    using ProxyClientCustom::ProxyClientCustom;
    ~ProxyClient();
    using M0 = ProxyClientMethodTraits<ipc::capnp::messages::RunLaterCallback::DestroyParams>;
    static typename M0::Result destroy(Super& super);
    using M1 = ProxyClientMethodTraits<ipc::capnp::messages::RunLaterCallback::CallParams>;
    typename M1::Result call();
};

template<>
struct ProxyServer<ipc::capnp::messages::RunLaterCallback> : public ProxyServerCustom<ipc::capnp::messages::RunLaterCallback, ProxyCallback<std::function<void()>>>
{
public:
    using ProxyServerCustom::ProxyServerCustom;
    ~ProxyServer();
    kj::Promise<void> destroy(DestroyContext call_context) override;
    kj::Promise<void> call(CallContext call_context) override;
};

template<>
struct ProxyStruct<ipc::capnp::messages::FoundBlockParam>
{
    using Struct = ipc::capnp::messages::FoundBlockParam;
    using WantHashAccessor = Accessor<chain_fields::WantHash, FIELD_IN | FIELD_OUT>;
    using WantHeightAccessor = Accessor<chain_fields::WantHeight, FIELD_IN | FIELD_OUT>;
    using WantTimeAccessor = Accessor<chain_fields::WantTime, FIELD_IN | FIELD_OUT>;
    using WantMaxTimeAccessor = Accessor<chain_fields::WantMaxTime, FIELD_IN | FIELD_OUT>;
    using WantMtpTimeAccessor = Accessor<chain_fields::WantMtpTime, FIELD_IN | FIELD_OUT>;
    using WantInActiveChainAccessor = Accessor<chain_fields::WantInActiveChain, FIELD_IN | FIELD_OUT>;
    using WantLocatorAccessor = Accessor<chain_fields::WantLocator, FIELD_IN | FIELD_OUT>;
    using NextBlockAccessor = Accessor<chain_fields::NextBlock, FIELD_IN | FIELD_OUT | FIELD_BOXED>;
    using WantDataAccessor = Accessor<chain_fields::WantData, FIELD_IN | FIELD_OUT>;
    using Accessors = std::tuple<WantHashAccessor, WantHeightAccessor, WantTimeAccessor, WantMaxTimeAccessor, WantMtpTimeAccessor, WantInActiveChainAccessor, WantLocatorAccessor, NextBlockAccessor, WantDataAccessor>;
    static constexpr size_t fields = 9;
};
template<>
struct ProxyStruct<ipc::capnp::messages::FoundBlockResult>
{
    using Struct = ipc::capnp::messages::FoundBlockResult;
    using HashAccessor = Accessor<chain_fields::Hash, FIELD_IN | FIELD_OUT | FIELD_BOXED>;
    using HeightAccessor = Accessor<chain_fields::Height, FIELD_IN | FIELD_OUT>;
    using TimeAccessor = Accessor<chain_fields::Time, FIELD_IN | FIELD_OUT>;
    using MaxTimeAccessor = Accessor<chain_fields::MaxTime, FIELD_IN | FIELD_OUT>;
    using MtpTimeAccessor = Accessor<chain_fields::MtpTime, FIELD_IN | FIELD_OUT>;
    using InActiveChainAccessor = Accessor<chain_fields::InActiveChain, FIELD_IN | FIELD_OUT>;
    using LocatorAccessor = Accessor<chain_fields::Locator, FIELD_IN | FIELD_OUT | FIELD_BOXED>;
    using NextBlockAccessor = Accessor<chain_fields::NextBlock, FIELD_IN | FIELD_OUT | FIELD_BOXED>;
    using DataAccessor = Accessor<chain_fields::Data, FIELD_IN | FIELD_OUT | FIELD_BOXED>;
    using FoundAccessor = Accessor<chain_fields::Found, FIELD_IN | FIELD_OUT>;
    using Accessors = std::tuple<HashAccessor, HeightAccessor, TimeAccessor, MaxTimeAccessor, MtpTimeAccessor, InActiveChainAccessor, LocatorAccessor, NextBlockAccessor, DataAccessor, FoundAccessor>;
    static constexpr size_t fields = 10;
};
template<>
struct ProxyStruct<ipc::capnp::messages::BlockInfo>
{
    using Struct = ipc::capnp::messages::BlockInfo;
    using HashAccessor = Accessor<chain_fields::Hash, FIELD_IN | FIELD_OUT | FIELD_BOXED>;
    using PrevHashAccessor = Accessor<chain_fields::PrevHash, FIELD_IN | FIELD_OUT | FIELD_BOXED>;
    using HeightAccessor = Accessor<chain_fields::Height, FIELD_IN | FIELD_OUT>;
    using FileNumberAccessor = Accessor<chain_fields::FileNumber, FIELD_IN | FIELD_OUT>;
    using DataPosAccessor = Accessor<chain_fields::DataPos, FIELD_IN | FIELD_OUT>;
    using DataAccessor = Accessor<chain_fields::Data, FIELD_IN | FIELD_OUT | FIELD_BOXED>;
    using UndoDataAccessor = Accessor<chain_fields::UndoData, FIELD_IN | FIELD_OUT | FIELD_BOXED>;
    using ChainTimeMaxAccessor = Accessor<chain_fields::ChainTimeMax, FIELD_IN | FIELD_OUT>;
    using Accessors = std::tuple<HeightAccessor, FileNumberAccessor, DataPosAccessor, ChainTimeMaxAccessor>;
    static constexpr size_t fields = 4;
};

template<>
struct ProxyClient<ipc::capnp::messages::SettingsUpdateCallback> final : public ProxyClientCustom<ipc::capnp::messages::SettingsUpdateCallback, ProxyCallback<interfaces::SettingsUpdate>>
{
public:
    using ProxyClientCustom::ProxyClientCustom;
    ~ProxyClient();
    using M0 = ProxyClientMethodTraits<ipc::capnp::messages::SettingsUpdateCallback::DestroyParams>;
    static typename M0::Result destroy(Super& super);
    using M1 = ProxyClientMethodTraits<ipc::capnp::messages::SettingsUpdateCallback::CallParams>;
    typename M1::Result call(M1::Param<0> value);
};

template<>
struct ProxyServer<ipc::capnp::messages::SettingsUpdateCallback> : public ProxyServerCustom<ipc::capnp::messages::SettingsUpdateCallback, ProxyCallback<interfaces::SettingsUpdate>>
{
public:
    using ProxyServerCustom::ProxyServerCustom;
    ~ProxyServer();
    kj::Promise<void> destroy(DestroyContext call_context) override;
    kj::Promise<void> call(CallContext call_context) override;
};

} // namespace mp
#if defined(__GNUC__)
#pragma GCC diagnostic pop
#endif
#endif
