// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: mining.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>
#if !CAPNP_LITE
#include <capnp/capability.h>
#endif  // !CAPNP_LITE

#ifndef CAPNP_VERSION
#error "CAPNP_VERSION is not defined, is capnp/generated-header-support.h missing?"
#elif CAPNP_VERSION != 1000001
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif

#include <mp/proxy.capnp.h>
#include "common.capnp.h"

CAPNP_BEGIN_HEADER

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(f9c68436df3af39e);
CAPNP_DECLARE_SCHEMA(d62a851f0a406fba);
CAPNP_DECLARE_SCHEMA(d26da946a6fc07cb);
CAPNP_DECLARE_SCHEMA(c086cb7153ed88c8);
CAPNP_DECLARE_SCHEMA(8aaddcee1cb5abe0);
CAPNP_DECLARE_SCHEMA(a6680fe2b3201a1e);
CAPNP_DECLARE_SCHEMA(cdbd83d7b2442034);
CAPNP_DECLARE_SCHEMA(e2dfd3582b92b229);
CAPNP_DECLARE_SCHEMA(8f132f96e3f130ea);
CAPNP_DECLARE_SCHEMA(f23d59d452aea8de);
CAPNP_DECLARE_SCHEMA(a0b06cebf3da9e15);
CAPNP_DECLARE_SCHEMA(f9671ad841b2f622);
CAPNP_DECLARE_SCHEMA(898c75958f8eab40);
CAPNP_DECLARE_SCHEMA(b277e9484368f871);
CAPNP_DECLARE_SCHEMA(bc6e961d0c9fabcb);
CAPNP_DECLARE_SCHEMA(be44866bf53ba50f);
CAPNP_DECLARE_SCHEMA(b57adc0c09d3d8b9);
CAPNP_DECLARE_SCHEMA(da570962f86bbd3b);
CAPNP_DECLARE_SCHEMA(fc48c88871b654d6);
CAPNP_DECLARE_SCHEMA(ce9419e947d3af78);
CAPNP_DECLARE_SCHEMA(8f4dadf0be3aee81);
CAPNP_DECLARE_SCHEMA(cf916f95f6f774fb);
CAPNP_DECLARE_SCHEMA(fd4337e403fdc1b8);
CAPNP_DECLARE_SCHEMA(e194427de3eafd96);
CAPNP_DECLARE_SCHEMA(a12657e0ad662f4b);
CAPNP_DECLARE_SCHEMA(da952a06f76488ff);
CAPNP_DECLARE_SCHEMA(f6e81eb0866e3b87);
CAPNP_DECLARE_SCHEMA(97f6899fb5e3c15f);
CAPNP_DECLARE_SCHEMA(b726a965fac04db3);
CAPNP_DECLARE_SCHEMA(dafdbfbfce655b00);
CAPNP_DECLARE_SCHEMA(b889895bf2d4ecb1);
CAPNP_DECLARE_SCHEMA(fe3cdff3007f0bc2);
CAPNP_DECLARE_SCHEMA(80fca083ef81a559);
CAPNP_DECLARE_SCHEMA(9f6631a52550e381);

}  // namespace schemas
}  // namespace capnp

namespace ipc {
namespace capnp {
namespace messages {

struct Mining {
  Mining() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct IsTestChainParams;
  struct IsTestChainResults;
  struct IsInitialBlockDownloadParams;
  struct IsInitialBlockDownloadResults;
  struct GetTipParams;
  struct GetTipResults;
  struct WaitTipChangedParams;
  struct WaitTipChangedResults;
  struct CreateNewBlockParams;
  struct CreateNewBlockResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(f9c68436df3af39e)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct Mining::IsTestChainParams {
  IsTestChainParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d62a851f0a406fba, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Mining::IsTestChainResults {
  IsTestChainResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d26da946a6fc07cb, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Mining::IsInitialBlockDownloadParams {
  IsInitialBlockDownloadParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c086cb7153ed88c8, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Mining::IsInitialBlockDownloadResults {
  IsInitialBlockDownloadResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8aaddcee1cb5abe0, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Mining::GetTipParams {
  GetTipParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a6680fe2b3201a1e, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Mining::GetTipResults {
  GetTipResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(cdbd83d7b2442034, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Mining::WaitTipChangedParams {
  WaitTipChangedParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e2dfd3582b92b229, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Mining::WaitTipChangedResults {
  WaitTipChangedResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8f132f96e3f130ea, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Mining::CreateNewBlockParams {
  CreateNewBlockParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f23d59d452aea8de, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Mining::CreateNewBlockResults {
  CreateNewBlockResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a0b06cebf3da9e15, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct BlockTemplate {
  BlockTemplate() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct DestroyParams;
  struct DestroyResults;
  struct GetBlockHeaderParams;
  struct GetBlockHeaderResults;
  struct GetBlockParams;
  struct GetBlockResults;
  struct GetTxFeesParams;
  struct GetTxFeesResults;
  struct GetTxSigopsParams;
  struct GetTxSigopsResults;
  struct GetCoinbaseTxParams;
  struct GetCoinbaseTxResults;
  struct GetCoinbaseCommitmentParams;
  struct GetCoinbaseCommitmentResults;
  struct GetWitnessCommitmentIndexParams;
  struct GetWitnessCommitmentIndexResults;
  struct GetCoinbaseMerklePathParams;
  struct GetCoinbaseMerklePathResults;
  struct SubmitSolutionParams;
  struct SubmitSolutionResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(f9671ad841b2f622)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct BlockTemplate::DestroyParams {
  DestroyParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(898c75958f8eab40, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct BlockTemplate::DestroyResults {
  DestroyResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b277e9484368f871, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct BlockTemplate::GetBlockHeaderParams {
  GetBlockHeaderParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bc6e961d0c9fabcb, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct BlockTemplate::GetBlockHeaderResults {
  GetBlockHeaderResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(be44866bf53ba50f, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct BlockTemplate::GetBlockParams {
  GetBlockParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b57adc0c09d3d8b9, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct BlockTemplate::GetBlockResults {
  GetBlockResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(da570962f86bbd3b, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct BlockTemplate::GetTxFeesParams {
  GetTxFeesParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fc48c88871b654d6, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct BlockTemplate::GetTxFeesResults {
  GetTxFeesResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ce9419e947d3af78, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct BlockTemplate::GetTxSigopsParams {
  GetTxSigopsParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8f4dadf0be3aee81, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct BlockTemplate::GetTxSigopsResults {
  GetTxSigopsResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(cf916f95f6f774fb, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct BlockTemplate::GetCoinbaseTxParams {
  GetCoinbaseTxParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fd4337e403fdc1b8, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct BlockTemplate::GetCoinbaseTxResults {
  GetCoinbaseTxResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e194427de3eafd96, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct BlockTemplate::GetCoinbaseCommitmentParams {
  GetCoinbaseCommitmentParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a12657e0ad662f4b, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct BlockTemplate::GetCoinbaseCommitmentResults {
  GetCoinbaseCommitmentResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(da952a06f76488ff, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct BlockTemplate::GetWitnessCommitmentIndexParams {
  GetWitnessCommitmentIndexParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f6e81eb0866e3b87, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct BlockTemplate::GetWitnessCommitmentIndexResults {
  GetWitnessCommitmentIndexResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(97f6899fb5e3c15f, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct BlockTemplate::GetCoinbaseMerklePathParams {
  GetCoinbaseMerklePathParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b726a965fac04db3, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct BlockTemplate::GetCoinbaseMerklePathResults {
  GetCoinbaseMerklePathResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(dafdbfbfce655b00, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct BlockTemplate::SubmitSolutionParams {
  SubmitSolutionParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b889895bf2d4ecb1, 2, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct BlockTemplate::SubmitSolutionResults {
  SubmitSolutionResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fe3cdff3007f0bc2, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct BlockCreateOptions {
  BlockCreateOptions() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(80fca083ef81a559, 3, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct BlockValidationState {
  BlockValidationState() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9f6631a52550e381, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

#if !CAPNP_LITE
class Mining::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef Mining Calls;
  typedef Mining Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::ipc::capnp::messages::Mining::IsTestChainParams,  ::ipc::capnp::messages::Mining::IsTestChainResults> isTestChainRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::ipc::capnp::messages::Mining::IsInitialBlockDownloadParams,  ::ipc::capnp::messages::Mining::IsInitialBlockDownloadResults> isInitialBlockDownloadRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::ipc::capnp::messages::Mining::GetTipParams,  ::ipc::capnp::messages::Mining::GetTipResults> getTipRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::ipc::capnp::messages::Mining::WaitTipChangedParams,  ::ipc::capnp::messages::Mining::WaitTipChangedResults> waitTipChangedRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::ipc::capnp::messages::Mining::CreateNewBlockParams,  ::ipc::capnp::messages::Mining::CreateNewBlockResults> createNewBlockRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class Mining::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef Mining Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::ipc::capnp::messages::Mining::IsTestChainParams IsTestChainParams;
  typedef  ::ipc::capnp::messages::Mining::IsTestChainResults IsTestChainResults;
  typedef ::capnp::CallContext<IsTestChainParams, IsTestChainResults> IsTestChainContext;
  virtual ::kj::Promise<void> isTestChain(IsTestChainContext context);
  typedef  ::ipc::capnp::messages::Mining::IsInitialBlockDownloadParams IsInitialBlockDownloadParams;
  typedef  ::ipc::capnp::messages::Mining::IsInitialBlockDownloadResults IsInitialBlockDownloadResults;
  typedef ::capnp::CallContext<IsInitialBlockDownloadParams, IsInitialBlockDownloadResults> IsInitialBlockDownloadContext;
  virtual ::kj::Promise<void> isInitialBlockDownload(IsInitialBlockDownloadContext context);
  typedef  ::ipc::capnp::messages::Mining::GetTipParams GetTipParams;
  typedef  ::ipc::capnp::messages::Mining::GetTipResults GetTipResults;
  typedef ::capnp::CallContext<GetTipParams, GetTipResults> GetTipContext;
  virtual ::kj::Promise<void> getTip(GetTipContext context);
  typedef  ::ipc::capnp::messages::Mining::WaitTipChangedParams WaitTipChangedParams;
  typedef  ::ipc::capnp::messages::Mining::WaitTipChangedResults WaitTipChangedResults;
  typedef ::capnp::CallContext<WaitTipChangedParams, WaitTipChangedResults> WaitTipChangedContext;
  virtual ::kj::Promise<void> waitTipChanged(WaitTipChangedContext context);
  typedef  ::ipc::capnp::messages::Mining::CreateNewBlockParams CreateNewBlockParams;
  typedef  ::ipc::capnp::messages::Mining::CreateNewBlockResults CreateNewBlockResults;
  typedef ::capnp::CallContext<CreateNewBlockParams, CreateNewBlockResults> CreateNewBlockContext;
  virtual ::kj::Promise<void> createNewBlock(CreateNewBlockContext context);

  inline  ::ipc::capnp::messages::Mining::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::ipc::capnp::messages::Mining>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class Mining::IsTestChainParams::Reader {
public:
  typedef IsTestChainParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasContext() const;
  inline  ::mp::Context::Reader getContext() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Mining::IsTestChainParams::Builder {
public:
  typedef IsTestChainParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasContext();
  inline  ::mp::Context::Builder getContext();
  inline void setContext( ::mp::Context::Reader value);
  inline  ::mp::Context::Builder initContext();
  inline void adoptContext(::capnp::Orphan< ::mp::Context>&& value);
  inline ::capnp::Orphan< ::mp::Context> disownContext();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Mining::IsTestChainParams::Pipeline {
public:
  typedef IsTestChainParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mp::Context::Pipeline getContext();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Mining::IsTestChainResults::Reader {
public:
  typedef IsTestChainResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool getResult() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Mining::IsTestChainResults::Builder {
public:
  typedef IsTestChainResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool getResult();
  inline void setResult(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Mining::IsTestChainResults::Pipeline {
public:
  typedef IsTestChainResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Mining::IsInitialBlockDownloadParams::Reader {
public:
  typedef IsInitialBlockDownloadParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasContext() const;
  inline  ::mp::Context::Reader getContext() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Mining::IsInitialBlockDownloadParams::Builder {
public:
  typedef IsInitialBlockDownloadParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasContext();
  inline  ::mp::Context::Builder getContext();
  inline void setContext( ::mp::Context::Reader value);
  inline  ::mp::Context::Builder initContext();
  inline void adoptContext(::capnp::Orphan< ::mp::Context>&& value);
  inline ::capnp::Orphan< ::mp::Context> disownContext();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Mining::IsInitialBlockDownloadParams::Pipeline {
public:
  typedef IsInitialBlockDownloadParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mp::Context::Pipeline getContext();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Mining::IsInitialBlockDownloadResults::Reader {
public:
  typedef IsInitialBlockDownloadResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool getResult() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Mining::IsInitialBlockDownloadResults::Builder {
public:
  typedef IsInitialBlockDownloadResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool getResult();
  inline void setResult(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Mining::IsInitialBlockDownloadResults::Pipeline {
public:
  typedef IsInitialBlockDownloadResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Mining::GetTipParams::Reader {
public:
  typedef GetTipParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasContext() const;
  inline  ::mp::Context::Reader getContext() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Mining::GetTipParams::Builder {
public:
  typedef GetTipParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasContext();
  inline  ::mp::Context::Builder getContext();
  inline void setContext( ::mp::Context::Reader value);
  inline  ::mp::Context::Builder initContext();
  inline void adoptContext(::capnp::Orphan< ::mp::Context>&& value);
  inline ::capnp::Orphan< ::mp::Context> disownContext();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Mining::GetTipParams::Pipeline {
public:
  typedef GetTipParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mp::Context::Pipeline getContext();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Mining::GetTipResults::Reader {
public:
  typedef GetTipResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasResult() const;
  inline  ::ipc::capnp::messages::BlockRef::Reader getResult() const;

  inline bool getHasResult() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Mining::GetTipResults::Builder {
public:
  typedef GetTipResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasResult();
  inline  ::ipc::capnp::messages::BlockRef::Builder getResult();
  inline void setResult( ::ipc::capnp::messages::BlockRef::Reader value);
  inline  ::ipc::capnp::messages::BlockRef::Builder initResult();
  inline void adoptResult(::capnp::Orphan< ::ipc::capnp::messages::BlockRef>&& value);
  inline ::capnp::Orphan< ::ipc::capnp::messages::BlockRef> disownResult();

  inline bool getHasResult();
  inline void setHasResult(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Mining::GetTipResults::Pipeline {
public:
  typedef GetTipResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::ipc::capnp::messages::BlockRef::Pipeline getResult();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Mining::WaitTipChangedParams::Reader {
public:
  typedef WaitTipChangedParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasContext() const;
  inline  ::mp::Context::Reader getContext() const;

  inline bool hasCurrentTip() const;
  inline  ::capnp::Data::Reader getCurrentTip() const;

  inline double getTimeout() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Mining::WaitTipChangedParams::Builder {
public:
  typedef WaitTipChangedParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasContext();
  inline  ::mp::Context::Builder getContext();
  inline void setContext( ::mp::Context::Reader value);
  inline  ::mp::Context::Builder initContext();
  inline void adoptContext(::capnp::Orphan< ::mp::Context>&& value);
  inline ::capnp::Orphan< ::mp::Context> disownContext();

  inline bool hasCurrentTip();
  inline  ::capnp::Data::Builder getCurrentTip();
  inline void setCurrentTip( ::capnp::Data::Reader value);
  inline  ::capnp::Data::Builder initCurrentTip(unsigned int size);
  inline void adoptCurrentTip(::capnp::Orphan< ::capnp::Data>&& value);
  inline ::capnp::Orphan< ::capnp::Data> disownCurrentTip();

  inline double getTimeout();
  inline void setTimeout(double value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Mining::WaitTipChangedParams::Pipeline {
public:
  typedef WaitTipChangedParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mp::Context::Pipeline getContext();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Mining::WaitTipChangedResults::Reader {
public:
  typedef WaitTipChangedResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasResult() const;
  inline  ::ipc::capnp::messages::BlockRef::Reader getResult() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Mining::WaitTipChangedResults::Builder {
public:
  typedef WaitTipChangedResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasResult();
  inline  ::ipc::capnp::messages::BlockRef::Builder getResult();
  inline void setResult( ::ipc::capnp::messages::BlockRef::Reader value);
  inline  ::ipc::capnp::messages::BlockRef::Builder initResult();
  inline void adoptResult(::capnp::Orphan< ::ipc::capnp::messages::BlockRef>&& value);
  inline ::capnp::Orphan< ::ipc::capnp::messages::BlockRef> disownResult();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Mining::WaitTipChangedResults::Pipeline {
public:
  typedef WaitTipChangedResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::ipc::capnp::messages::BlockRef::Pipeline getResult();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Mining::CreateNewBlockParams::Reader {
public:
  typedef CreateNewBlockParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasOptions() const;
  inline  ::ipc::capnp::messages::BlockCreateOptions::Reader getOptions() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Mining::CreateNewBlockParams::Builder {
public:
  typedef CreateNewBlockParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasOptions();
  inline  ::ipc::capnp::messages::BlockCreateOptions::Builder getOptions();
  inline void setOptions( ::ipc::capnp::messages::BlockCreateOptions::Reader value);
  inline  ::ipc::capnp::messages::BlockCreateOptions::Builder initOptions();
  inline void adoptOptions(::capnp::Orphan< ::ipc::capnp::messages::BlockCreateOptions>&& value);
  inline ::capnp::Orphan< ::ipc::capnp::messages::BlockCreateOptions> disownOptions();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Mining::CreateNewBlockParams::Pipeline {
public:
  typedef CreateNewBlockParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::ipc::capnp::messages::BlockCreateOptions::Pipeline getOptions();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Mining::CreateNewBlockResults::Reader {
public:
  typedef CreateNewBlockResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasResult() const;
#if !CAPNP_LITE
  inline  ::ipc::capnp::messages::BlockTemplate::Client getResult() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Mining::CreateNewBlockResults::Builder {
public:
  typedef CreateNewBlockResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasResult();
#if !CAPNP_LITE
  inline  ::ipc::capnp::messages::BlockTemplate::Client getResult();
  inline void setResult( ::ipc::capnp::messages::BlockTemplate::Client&& value);
  inline void setResult( ::ipc::capnp::messages::BlockTemplate::Client& value);
  inline void adoptResult(::capnp::Orphan< ::ipc::capnp::messages::BlockTemplate>&& value);
  inline ::capnp::Orphan< ::ipc::capnp::messages::BlockTemplate> disownResult();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Mining::CreateNewBlockResults::Pipeline {
public:
  typedef CreateNewBlockResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::ipc::capnp::messages::BlockTemplate::Client getResult();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class BlockTemplate::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef BlockTemplate Calls;
  typedef BlockTemplate Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::ipc::capnp::messages::BlockTemplate::DestroyParams,  ::ipc::capnp::messages::BlockTemplate::DestroyResults> destroyRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::ipc::capnp::messages::BlockTemplate::GetBlockHeaderParams,  ::ipc::capnp::messages::BlockTemplate::GetBlockHeaderResults> getBlockHeaderRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::ipc::capnp::messages::BlockTemplate::GetBlockParams,  ::ipc::capnp::messages::BlockTemplate::GetBlockResults> getBlockRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::ipc::capnp::messages::BlockTemplate::GetTxFeesParams,  ::ipc::capnp::messages::BlockTemplate::GetTxFeesResults> getTxFeesRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::ipc::capnp::messages::BlockTemplate::GetTxSigopsParams,  ::ipc::capnp::messages::BlockTemplate::GetTxSigopsResults> getTxSigopsRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::ipc::capnp::messages::BlockTemplate::GetCoinbaseTxParams,  ::ipc::capnp::messages::BlockTemplate::GetCoinbaseTxResults> getCoinbaseTxRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::ipc::capnp::messages::BlockTemplate::GetCoinbaseCommitmentParams,  ::ipc::capnp::messages::BlockTemplate::GetCoinbaseCommitmentResults> getCoinbaseCommitmentRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::ipc::capnp::messages::BlockTemplate::GetWitnessCommitmentIndexParams,  ::ipc::capnp::messages::BlockTemplate::GetWitnessCommitmentIndexResults> getWitnessCommitmentIndexRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::ipc::capnp::messages::BlockTemplate::GetCoinbaseMerklePathParams,  ::ipc::capnp::messages::BlockTemplate::GetCoinbaseMerklePathResults> getCoinbaseMerklePathRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::ipc::capnp::messages::BlockTemplate::SubmitSolutionParams,  ::ipc::capnp::messages::BlockTemplate::SubmitSolutionResults> submitSolutionRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class BlockTemplate::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef BlockTemplate Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::ipc::capnp::messages::BlockTemplate::DestroyParams DestroyParams;
  typedef  ::ipc::capnp::messages::BlockTemplate::DestroyResults DestroyResults;
  typedef ::capnp::CallContext<DestroyParams, DestroyResults> DestroyContext;
  virtual ::kj::Promise<void> destroy(DestroyContext context);
  typedef  ::ipc::capnp::messages::BlockTemplate::GetBlockHeaderParams GetBlockHeaderParams;
  typedef  ::ipc::capnp::messages::BlockTemplate::GetBlockHeaderResults GetBlockHeaderResults;
  typedef ::capnp::CallContext<GetBlockHeaderParams, GetBlockHeaderResults> GetBlockHeaderContext;
  virtual ::kj::Promise<void> getBlockHeader(GetBlockHeaderContext context);
  typedef  ::ipc::capnp::messages::BlockTemplate::GetBlockParams GetBlockParams;
  typedef  ::ipc::capnp::messages::BlockTemplate::GetBlockResults GetBlockResults;
  typedef ::capnp::CallContext<GetBlockParams, GetBlockResults> GetBlockContext;
  virtual ::kj::Promise<void> getBlock(GetBlockContext context);
  typedef  ::ipc::capnp::messages::BlockTemplate::GetTxFeesParams GetTxFeesParams;
  typedef  ::ipc::capnp::messages::BlockTemplate::GetTxFeesResults GetTxFeesResults;
  typedef ::capnp::CallContext<GetTxFeesParams, GetTxFeesResults> GetTxFeesContext;
  virtual ::kj::Promise<void> getTxFees(GetTxFeesContext context);
  typedef  ::ipc::capnp::messages::BlockTemplate::GetTxSigopsParams GetTxSigopsParams;
  typedef  ::ipc::capnp::messages::BlockTemplate::GetTxSigopsResults GetTxSigopsResults;
  typedef ::capnp::CallContext<GetTxSigopsParams, GetTxSigopsResults> GetTxSigopsContext;
  virtual ::kj::Promise<void> getTxSigops(GetTxSigopsContext context);
  typedef  ::ipc::capnp::messages::BlockTemplate::GetCoinbaseTxParams GetCoinbaseTxParams;
  typedef  ::ipc::capnp::messages::BlockTemplate::GetCoinbaseTxResults GetCoinbaseTxResults;
  typedef ::capnp::CallContext<GetCoinbaseTxParams, GetCoinbaseTxResults> GetCoinbaseTxContext;
  virtual ::kj::Promise<void> getCoinbaseTx(GetCoinbaseTxContext context);
  typedef  ::ipc::capnp::messages::BlockTemplate::GetCoinbaseCommitmentParams GetCoinbaseCommitmentParams;
  typedef  ::ipc::capnp::messages::BlockTemplate::GetCoinbaseCommitmentResults GetCoinbaseCommitmentResults;
  typedef ::capnp::CallContext<GetCoinbaseCommitmentParams, GetCoinbaseCommitmentResults> GetCoinbaseCommitmentContext;
  virtual ::kj::Promise<void> getCoinbaseCommitment(GetCoinbaseCommitmentContext context);
  typedef  ::ipc::capnp::messages::BlockTemplate::GetWitnessCommitmentIndexParams GetWitnessCommitmentIndexParams;
  typedef  ::ipc::capnp::messages::BlockTemplate::GetWitnessCommitmentIndexResults GetWitnessCommitmentIndexResults;
  typedef ::capnp::CallContext<GetWitnessCommitmentIndexParams, GetWitnessCommitmentIndexResults> GetWitnessCommitmentIndexContext;
  virtual ::kj::Promise<void> getWitnessCommitmentIndex(GetWitnessCommitmentIndexContext context);
  typedef  ::ipc::capnp::messages::BlockTemplate::GetCoinbaseMerklePathParams GetCoinbaseMerklePathParams;
  typedef  ::ipc::capnp::messages::BlockTemplate::GetCoinbaseMerklePathResults GetCoinbaseMerklePathResults;
  typedef ::capnp::CallContext<GetCoinbaseMerklePathParams, GetCoinbaseMerklePathResults> GetCoinbaseMerklePathContext;
  virtual ::kj::Promise<void> getCoinbaseMerklePath(GetCoinbaseMerklePathContext context);
  typedef  ::ipc::capnp::messages::BlockTemplate::SubmitSolutionParams SubmitSolutionParams;
  typedef  ::ipc::capnp::messages::BlockTemplate::SubmitSolutionResults SubmitSolutionResults;
  typedef ::capnp::CallContext<SubmitSolutionParams, SubmitSolutionResults> SubmitSolutionContext;
  virtual ::kj::Promise<void> submitSolution(SubmitSolutionContext context);

  inline  ::ipc::capnp::messages::BlockTemplate::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::ipc::capnp::messages::BlockTemplate>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class BlockTemplate::DestroyParams::Reader {
public:
  typedef DestroyParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasContext() const;
  inline  ::mp::Context::Reader getContext() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class BlockTemplate::DestroyParams::Builder {
public:
  typedef DestroyParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasContext();
  inline  ::mp::Context::Builder getContext();
  inline void setContext( ::mp::Context::Reader value);
  inline  ::mp::Context::Builder initContext();
  inline void adoptContext(::capnp::Orphan< ::mp::Context>&& value);
  inline ::capnp::Orphan< ::mp::Context> disownContext();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class BlockTemplate::DestroyParams::Pipeline {
public:
  typedef DestroyParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mp::Context::Pipeline getContext();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class BlockTemplate::DestroyResults::Reader {
public:
  typedef DestroyResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class BlockTemplate::DestroyResults::Builder {
public:
  typedef DestroyResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class BlockTemplate::DestroyResults::Pipeline {
public:
  typedef DestroyResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class BlockTemplate::GetBlockHeaderParams::Reader {
public:
  typedef GetBlockHeaderParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasContext() const;
  inline  ::mp::Context::Reader getContext() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class BlockTemplate::GetBlockHeaderParams::Builder {
public:
  typedef GetBlockHeaderParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasContext();
  inline  ::mp::Context::Builder getContext();
  inline void setContext( ::mp::Context::Reader value);
  inline  ::mp::Context::Builder initContext();
  inline void adoptContext(::capnp::Orphan< ::mp::Context>&& value);
  inline ::capnp::Orphan< ::mp::Context> disownContext();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class BlockTemplate::GetBlockHeaderParams::Pipeline {
public:
  typedef GetBlockHeaderParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mp::Context::Pipeline getContext();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class BlockTemplate::GetBlockHeaderResults::Reader {
public:
  typedef GetBlockHeaderResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasResult() const;
  inline  ::capnp::Data::Reader getResult() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class BlockTemplate::GetBlockHeaderResults::Builder {
public:
  typedef GetBlockHeaderResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasResult();
  inline  ::capnp::Data::Builder getResult();
  inline void setResult( ::capnp::Data::Reader value);
  inline  ::capnp::Data::Builder initResult(unsigned int size);
  inline void adoptResult(::capnp::Orphan< ::capnp::Data>&& value);
  inline ::capnp::Orphan< ::capnp::Data> disownResult();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class BlockTemplate::GetBlockHeaderResults::Pipeline {
public:
  typedef GetBlockHeaderResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class BlockTemplate::GetBlockParams::Reader {
public:
  typedef GetBlockParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasContext() const;
  inline  ::mp::Context::Reader getContext() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class BlockTemplate::GetBlockParams::Builder {
public:
  typedef GetBlockParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasContext();
  inline  ::mp::Context::Builder getContext();
  inline void setContext( ::mp::Context::Reader value);
  inline  ::mp::Context::Builder initContext();
  inline void adoptContext(::capnp::Orphan< ::mp::Context>&& value);
  inline ::capnp::Orphan< ::mp::Context> disownContext();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class BlockTemplate::GetBlockParams::Pipeline {
public:
  typedef GetBlockParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mp::Context::Pipeline getContext();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class BlockTemplate::GetBlockResults::Reader {
public:
  typedef GetBlockResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasResult() const;
  inline  ::capnp::Data::Reader getResult() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class BlockTemplate::GetBlockResults::Builder {
public:
  typedef GetBlockResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasResult();
  inline  ::capnp::Data::Builder getResult();
  inline void setResult( ::capnp::Data::Reader value);
  inline  ::capnp::Data::Builder initResult(unsigned int size);
  inline void adoptResult(::capnp::Orphan< ::capnp::Data>&& value);
  inline ::capnp::Orphan< ::capnp::Data> disownResult();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class BlockTemplate::GetBlockResults::Pipeline {
public:
  typedef GetBlockResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class BlockTemplate::GetTxFeesParams::Reader {
public:
  typedef GetTxFeesParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasContext() const;
  inline  ::mp::Context::Reader getContext() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class BlockTemplate::GetTxFeesParams::Builder {
public:
  typedef GetTxFeesParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasContext();
  inline  ::mp::Context::Builder getContext();
  inline void setContext( ::mp::Context::Reader value);
  inline  ::mp::Context::Builder initContext();
  inline void adoptContext(::capnp::Orphan< ::mp::Context>&& value);
  inline ::capnp::Orphan< ::mp::Context> disownContext();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class BlockTemplate::GetTxFeesParams::Pipeline {
public:
  typedef GetTxFeesParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mp::Context::Pipeline getContext();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class BlockTemplate::GetTxFeesResults::Reader {
public:
  typedef GetTxFeesResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasResult() const;
  inline  ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>::Reader getResult() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class BlockTemplate::GetTxFeesResults::Builder {
public:
  typedef GetTxFeesResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasResult();
  inline  ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>::Builder getResult();
  inline void setResult( ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setResult(::kj::ArrayPtr<const  ::int64_t> value);
  inline  ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>::Builder initResult(unsigned int size);
  inline void adoptResult(::capnp::Orphan< ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>> disownResult();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class BlockTemplate::GetTxFeesResults::Pipeline {
public:
  typedef GetTxFeesResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class BlockTemplate::GetTxSigopsParams::Reader {
public:
  typedef GetTxSigopsParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasContext() const;
  inline  ::mp::Context::Reader getContext() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class BlockTemplate::GetTxSigopsParams::Builder {
public:
  typedef GetTxSigopsParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasContext();
  inline  ::mp::Context::Builder getContext();
  inline void setContext( ::mp::Context::Reader value);
  inline  ::mp::Context::Builder initContext();
  inline void adoptContext(::capnp::Orphan< ::mp::Context>&& value);
  inline ::capnp::Orphan< ::mp::Context> disownContext();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class BlockTemplate::GetTxSigopsParams::Pipeline {
public:
  typedef GetTxSigopsParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mp::Context::Pipeline getContext();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class BlockTemplate::GetTxSigopsResults::Reader {
public:
  typedef GetTxSigopsResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasResult() const;
  inline  ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>::Reader getResult() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class BlockTemplate::GetTxSigopsResults::Builder {
public:
  typedef GetTxSigopsResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasResult();
  inline  ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>::Builder getResult();
  inline void setResult( ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setResult(::kj::ArrayPtr<const  ::int64_t> value);
  inline  ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>::Builder initResult(unsigned int size);
  inline void adoptResult(::capnp::Orphan< ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>> disownResult();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class BlockTemplate::GetTxSigopsResults::Pipeline {
public:
  typedef GetTxSigopsResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class BlockTemplate::GetCoinbaseTxParams::Reader {
public:
  typedef GetCoinbaseTxParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasContext() const;
  inline  ::mp::Context::Reader getContext() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class BlockTemplate::GetCoinbaseTxParams::Builder {
public:
  typedef GetCoinbaseTxParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasContext();
  inline  ::mp::Context::Builder getContext();
  inline void setContext( ::mp::Context::Reader value);
  inline  ::mp::Context::Builder initContext();
  inline void adoptContext(::capnp::Orphan< ::mp::Context>&& value);
  inline ::capnp::Orphan< ::mp::Context> disownContext();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class BlockTemplate::GetCoinbaseTxParams::Pipeline {
public:
  typedef GetCoinbaseTxParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mp::Context::Pipeline getContext();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class BlockTemplate::GetCoinbaseTxResults::Reader {
public:
  typedef GetCoinbaseTxResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasResult() const;
  inline  ::capnp::Data::Reader getResult() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class BlockTemplate::GetCoinbaseTxResults::Builder {
public:
  typedef GetCoinbaseTxResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasResult();
  inline  ::capnp::Data::Builder getResult();
  inline void setResult( ::capnp::Data::Reader value);
  inline  ::capnp::Data::Builder initResult(unsigned int size);
  inline void adoptResult(::capnp::Orphan< ::capnp::Data>&& value);
  inline ::capnp::Orphan< ::capnp::Data> disownResult();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class BlockTemplate::GetCoinbaseTxResults::Pipeline {
public:
  typedef GetCoinbaseTxResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class BlockTemplate::GetCoinbaseCommitmentParams::Reader {
public:
  typedef GetCoinbaseCommitmentParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasContext() const;
  inline  ::mp::Context::Reader getContext() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class BlockTemplate::GetCoinbaseCommitmentParams::Builder {
public:
  typedef GetCoinbaseCommitmentParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasContext();
  inline  ::mp::Context::Builder getContext();
  inline void setContext( ::mp::Context::Reader value);
  inline  ::mp::Context::Builder initContext();
  inline void adoptContext(::capnp::Orphan< ::mp::Context>&& value);
  inline ::capnp::Orphan< ::mp::Context> disownContext();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class BlockTemplate::GetCoinbaseCommitmentParams::Pipeline {
public:
  typedef GetCoinbaseCommitmentParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mp::Context::Pipeline getContext();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class BlockTemplate::GetCoinbaseCommitmentResults::Reader {
public:
  typedef GetCoinbaseCommitmentResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasResult() const;
  inline  ::capnp::Data::Reader getResult() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class BlockTemplate::GetCoinbaseCommitmentResults::Builder {
public:
  typedef GetCoinbaseCommitmentResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasResult();
  inline  ::capnp::Data::Builder getResult();
  inline void setResult( ::capnp::Data::Reader value);
  inline  ::capnp::Data::Builder initResult(unsigned int size);
  inline void adoptResult(::capnp::Orphan< ::capnp::Data>&& value);
  inline ::capnp::Orphan< ::capnp::Data> disownResult();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class BlockTemplate::GetCoinbaseCommitmentResults::Pipeline {
public:
  typedef GetCoinbaseCommitmentResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class BlockTemplate::GetWitnessCommitmentIndexParams::Reader {
public:
  typedef GetWitnessCommitmentIndexParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasContext() const;
  inline  ::mp::Context::Reader getContext() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class BlockTemplate::GetWitnessCommitmentIndexParams::Builder {
public:
  typedef GetWitnessCommitmentIndexParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasContext();
  inline  ::mp::Context::Builder getContext();
  inline void setContext( ::mp::Context::Reader value);
  inline  ::mp::Context::Builder initContext();
  inline void adoptContext(::capnp::Orphan< ::mp::Context>&& value);
  inline ::capnp::Orphan< ::mp::Context> disownContext();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class BlockTemplate::GetWitnessCommitmentIndexParams::Pipeline {
public:
  typedef GetWitnessCommitmentIndexParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mp::Context::Pipeline getContext();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class BlockTemplate::GetWitnessCommitmentIndexResults::Reader {
public:
  typedef GetWitnessCommitmentIndexResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int32_t getResult() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class BlockTemplate::GetWitnessCommitmentIndexResults::Builder {
public:
  typedef GetWitnessCommitmentIndexResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int32_t getResult();
  inline void setResult( ::int32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class BlockTemplate::GetWitnessCommitmentIndexResults::Pipeline {
public:
  typedef GetWitnessCommitmentIndexResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class BlockTemplate::GetCoinbaseMerklePathParams::Reader {
public:
  typedef GetCoinbaseMerklePathParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasContext() const;
  inline  ::mp::Context::Reader getContext() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class BlockTemplate::GetCoinbaseMerklePathParams::Builder {
public:
  typedef GetCoinbaseMerklePathParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasContext();
  inline  ::mp::Context::Builder getContext();
  inline void setContext( ::mp::Context::Reader value);
  inline  ::mp::Context::Builder initContext();
  inline void adoptContext(::capnp::Orphan< ::mp::Context>&& value);
  inline ::capnp::Orphan< ::mp::Context> disownContext();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class BlockTemplate::GetCoinbaseMerklePathParams::Pipeline {
public:
  typedef GetCoinbaseMerklePathParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mp::Context::Pipeline getContext();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class BlockTemplate::GetCoinbaseMerklePathResults::Reader {
public:
  typedef GetCoinbaseMerklePathResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasResult() const;
  inline  ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>::Reader getResult() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class BlockTemplate::GetCoinbaseMerklePathResults::Builder {
public:
  typedef GetCoinbaseMerklePathResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasResult();
  inline  ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>::Builder getResult();
  inline void setResult( ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>::Reader value);
  inline void setResult(::kj::ArrayPtr<const  ::capnp::Data::Reader> value);
  inline  ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>::Builder initResult(unsigned int size);
  inline void adoptResult(::capnp::Orphan< ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>> disownResult();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class BlockTemplate::GetCoinbaseMerklePathResults::Pipeline {
public:
  typedef GetCoinbaseMerklePathResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class BlockTemplate::SubmitSolutionParams::Reader {
public:
  typedef SubmitSolutionParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasContext() const;
  inline  ::mp::Context::Reader getContext() const;

  inline  ::uint32_t getVersion() const;

  inline  ::uint32_t getTimestamp() const;

  inline  ::uint32_t getNonce() const;

  inline bool hasCoinbase() const;
  inline  ::capnp::Data::Reader getCoinbase() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class BlockTemplate::SubmitSolutionParams::Builder {
public:
  typedef SubmitSolutionParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasContext();
  inline  ::mp::Context::Builder getContext();
  inline void setContext( ::mp::Context::Reader value);
  inline  ::mp::Context::Builder initContext();
  inline void adoptContext(::capnp::Orphan< ::mp::Context>&& value);
  inline ::capnp::Orphan< ::mp::Context> disownContext();

  inline  ::uint32_t getVersion();
  inline void setVersion( ::uint32_t value);

  inline  ::uint32_t getTimestamp();
  inline void setTimestamp( ::uint32_t value);

  inline  ::uint32_t getNonce();
  inline void setNonce( ::uint32_t value);

  inline bool hasCoinbase();
  inline  ::capnp::Data::Builder getCoinbase();
  inline void setCoinbase( ::capnp::Data::Reader value);
  inline  ::capnp::Data::Builder initCoinbase(unsigned int size);
  inline void adoptCoinbase(::capnp::Orphan< ::capnp::Data>&& value);
  inline ::capnp::Orphan< ::capnp::Data> disownCoinbase();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class BlockTemplate::SubmitSolutionParams::Pipeline {
public:
  typedef SubmitSolutionParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mp::Context::Pipeline getContext();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class BlockTemplate::SubmitSolutionResults::Reader {
public:
  typedef SubmitSolutionResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool getResult() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class BlockTemplate::SubmitSolutionResults::Builder {
public:
  typedef SubmitSolutionResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool getResult();
  inline void setResult(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class BlockTemplate::SubmitSolutionResults::Pipeline {
public:
  typedef SubmitSolutionResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class BlockCreateOptions::Reader {
public:
  typedef BlockCreateOptions Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool getUseMempool() const;

  inline  ::uint64_t getBlockReservedWeight() const;

  inline  ::uint64_t getCoinbaseOutputMaxAdditionalSigops() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class BlockCreateOptions::Builder {
public:
  typedef BlockCreateOptions Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool getUseMempool();
  inline void setUseMempool(bool value);

  inline  ::uint64_t getBlockReservedWeight();
  inline void setBlockReservedWeight( ::uint64_t value);

  inline  ::uint64_t getCoinbaseOutputMaxAdditionalSigops();
  inline void setCoinbaseOutputMaxAdditionalSigops( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class BlockCreateOptions::Pipeline {
public:
  typedef BlockCreateOptions Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class BlockValidationState::Reader {
public:
  typedef BlockValidationState Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int32_t getMode() const;

  inline  ::int32_t getResult() const;

  inline bool hasRejectReason() const;
  inline  ::capnp::Text::Reader getRejectReason() const;

  inline bool hasDebugMessage() const;
  inline  ::capnp::Text::Reader getDebugMessage() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class BlockValidationState::Builder {
public:
  typedef BlockValidationState Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int32_t getMode();
  inline void setMode( ::int32_t value);

  inline  ::int32_t getResult();
  inline void setResult( ::int32_t value);

  inline bool hasRejectReason();
  inline  ::capnp::Text::Builder getRejectReason();
  inline void setRejectReason( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initRejectReason(unsigned int size);
  inline void adoptRejectReason(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownRejectReason();

  inline bool hasDebugMessage();
  inline  ::capnp::Text::Builder getDebugMessage();
  inline void setDebugMessage( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initDebugMessage(unsigned int size);
  inline void adoptDebugMessage(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownDebugMessage();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class BlockValidationState::Pipeline {
public:
  typedef BlockValidationState Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

#if !CAPNP_LITE
inline Mining::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline Mining::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline Mining::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline Mining::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline Mining::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::ipc::capnp::messages::Mining::Client& Mining::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::ipc::capnp::messages::Mining::Client& Mining::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool Mining::IsTestChainParams::Reader::hasContext() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Mining::IsTestChainParams::Builder::hasContext() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mp::Context::Reader Mining::IsTestChainParams::Reader::getContext() const {
  return ::capnp::_::PointerHelpers< ::mp::Context>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mp::Context::Builder Mining::IsTestChainParams::Builder::getContext() {
  return ::capnp::_::PointerHelpers< ::mp::Context>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mp::Context::Pipeline Mining::IsTestChainParams::Pipeline::getContext() {
  return  ::mp::Context::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Mining::IsTestChainParams::Builder::setContext( ::mp::Context::Reader value) {
  ::capnp::_::PointerHelpers< ::mp::Context>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mp::Context::Builder Mining::IsTestChainParams::Builder::initContext() {
  return ::capnp::_::PointerHelpers< ::mp::Context>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Mining::IsTestChainParams::Builder::adoptContext(
    ::capnp::Orphan< ::mp::Context>&& value) {
  ::capnp::_::PointerHelpers< ::mp::Context>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mp::Context> Mining::IsTestChainParams::Builder::disownContext() {
  return ::capnp::_::PointerHelpers< ::mp::Context>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Mining::IsTestChainResults::Reader::getResult() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Mining::IsTestChainResults::Builder::getResult() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Mining::IsTestChainResults::Builder::setResult(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Mining::IsInitialBlockDownloadParams::Reader::hasContext() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Mining::IsInitialBlockDownloadParams::Builder::hasContext() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mp::Context::Reader Mining::IsInitialBlockDownloadParams::Reader::getContext() const {
  return ::capnp::_::PointerHelpers< ::mp::Context>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mp::Context::Builder Mining::IsInitialBlockDownloadParams::Builder::getContext() {
  return ::capnp::_::PointerHelpers< ::mp::Context>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mp::Context::Pipeline Mining::IsInitialBlockDownloadParams::Pipeline::getContext() {
  return  ::mp::Context::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Mining::IsInitialBlockDownloadParams::Builder::setContext( ::mp::Context::Reader value) {
  ::capnp::_::PointerHelpers< ::mp::Context>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mp::Context::Builder Mining::IsInitialBlockDownloadParams::Builder::initContext() {
  return ::capnp::_::PointerHelpers< ::mp::Context>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Mining::IsInitialBlockDownloadParams::Builder::adoptContext(
    ::capnp::Orphan< ::mp::Context>&& value) {
  ::capnp::_::PointerHelpers< ::mp::Context>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mp::Context> Mining::IsInitialBlockDownloadParams::Builder::disownContext() {
  return ::capnp::_::PointerHelpers< ::mp::Context>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Mining::IsInitialBlockDownloadResults::Reader::getResult() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Mining::IsInitialBlockDownloadResults::Builder::getResult() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Mining::IsInitialBlockDownloadResults::Builder::setResult(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Mining::GetTipParams::Reader::hasContext() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Mining::GetTipParams::Builder::hasContext() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mp::Context::Reader Mining::GetTipParams::Reader::getContext() const {
  return ::capnp::_::PointerHelpers< ::mp::Context>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mp::Context::Builder Mining::GetTipParams::Builder::getContext() {
  return ::capnp::_::PointerHelpers< ::mp::Context>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mp::Context::Pipeline Mining::GetTipParams::Pipeline::getContext() {
  return  ::mp::Context::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Mining::GetTipParams::Builder::setContext( ::mp::Context::Reader value) {
  ::capnp::_::PointerHelpers< ::mp::Context>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mp::Context::Builder Mining::GetTipParams::Builder::initContext() {
  return ::capnp::_::PointerHelpers< ::mp::Context>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Mining::GetTipParams::Builder::adoptContext(
    ::capnp::Orphan< ::mp::Context>&& value) {
  ::capnp::_::PointerHelpers< ::mp::Context>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mp::Context> Mining::GetTipParams::Builder::disownContext() {
  return ::capnp::_::PointerHelpers< ::mp::Context>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Mining::GetTipResults::Reader::hasResult() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Mining::GetTipResults::Builder::hasResult() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::ipc::capnp::messages::BlockRef::Reader Mining::GetTipResults::Reader::getResult() const {
  return ::capnp::_::PointerHelpers< ::ipc::capnp::messages::BlockRef>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::ipc::capnp::messages::BlockRef::Builder Mining::GetTipResults::Builder::getResult() {
  return ::capnp::_::PointerHelpers< ::ipc::capnp::messages::BlockRef>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::ipc::capnp::messages::BlockRef::Pipeline Mining::GetTipResults::Pipeline::getResult() {
  return  ::ipc::capnp::messages::BlockRef::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Mining::GetTipResults::Builder::setResult( ::ipc::capnp::messages::BlockRef::Reader value) {
  ::capnp::_::PointerHelpers< ::ipc::capnp::messages::BlockRef>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::ipc::capnp::messages::BlockRef::Builder Mining::GetTipResults::Builder::initResult() {
  return ::capnp::_::PointerHelpers< ::ipc::capnp::messages::BlockRef>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Mining::GetTipResults::Builder::adoptResult(
    ::capnp::Orphan< ::ipc::capnp::messages::BlockRef>&& value) {
  ::capnp::_::PointerHelpers< ::ipc::capnp::messages::BlockRef>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::ipc::capnp::messages::BlockRef> Mining::GetTipResults::Builder::disownResult() {
  return ::capnp::_::PointerHelpers< ::ipc::capnp::messages::BlockRef>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Mining::GetTipResults::Reader::getHasResult() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Mining::GetTipResults::Builder::getHasResult() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Mining::GetTipResults::Builder::setHasResult(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Mining::WaitTipChangedParams::Reader::hasContext() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Mining::WaitTipChangedParams::Builder::hasContext() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mp::Context::Reader Mining::WaitTipChangedParams::Reader::getContext() const {
  return ::capnp::_::PointerHelpers< ::mp::Context>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mp::Context::Builder Mining::WaitTipChangedParams::Builder::getContext() {
  return ::capnp::_::PointerHelpers< ::mp::Context>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mp::Context::Pipeline Mining::WaitTipChangedParams::Pipeline::getContext() {
  return  ::mp::Context::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Mining::WaitTipChangedParams::Builder::setContext( ::mp::Context::Reader value) {
  ::capnp::_::PointerHelpers< ::mp::Context>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mp::Context::Builder Mining::WaitTipChangedParams::Builder::initContext() {
  return ::capnp::_::PointerHelpers< ::mp::Context>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Mining::WaitTipChangedParams::Builder::adoptContext(
    ::capnp::Orphan< ::mp::Context>&& value) {
  ::capnp::_::PointerHelpers< ::mp::Context>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mp::Context> Mining::WaitTipChangedParams::Builder::disownContext() {
  return ::capnp::_::PointerHelpers< ::mp::Context>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Mining::WaitTipChangedParams::Reader::hasCurrentTip() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Mining::WaitTipChangedParams::Builder::hasCurrentTip() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Data::Reader Mining::WaitTipChangedParams::Reader::getCurrentTip() const {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Data::Builder Mining::WaitTipChangedParams::Builder::getCurrentTip() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Mining::WaitTipChangedParams::Builder::setCurrentTip( ::capnp::Data::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Data::Builder Mining::WaitTipChangedParams::Builder::initCurrentTip(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Mining::WaitTipChangedParams::Builder::adoptCurrentTip(
    ::capnp::Orphan< ::capnp::Data>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Data> Mining::WaitTipChangedParams::Builder::disownCurrentTip() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline double Mining::WaitTipChangedParams::Reader::getTimeout() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline double Mining::WaitTipChangedParams::Builder::getTimeout() {
  return _builder.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Mining::WaitTipChangedParams::Builder::setTimeout(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Mining::WaitTipChangedResults::Reader::hasResult() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Mining::WaitTipChangedResults::Builder::hasResult() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::ipc::capnp::messages::BlockRef::Reader Mining::WaitTipChangedResults::Reader::getResult() const {
  return ::capnp::_::PointerHelpers< ::ipc::capnp::messages::BlockRef>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::ipc::capnp::messages::BlockRef::Builder Mining::WaitTipChangedResults::Builder::getResult() {
  return ::capnp::_::PointerHelpers< ::ipc::capnp::messages::BlockRef>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::ipc::capnp::messages::BlockRef::Pipeline Mining::WaitTipChangedResults::Pipeline::getResult() {
  return  ::ipc::capnp::messages::BlockRef::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Mining::WaitTipChangedResults::Builder::setResult( ::ipc::capnp::messages::BlockRef::Reader value) {
  ::capnp::_::PointerHelpers< ::ipc::capnp::messages::BlockRef>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::ipc::capnp::messages::BlockRef::Builder Mining::WaitTipChangedResults::Builder::initResult() {
  return ::capnp::_::PointerHelpers< ::ipc::capnp::messages::BlockRef>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Mining::WaitTipChangedResults::Builder::adoptResult(
    ::capnp::Orphan< ::ipc::capnp::messages::BlockRef>&& value) {
  ::capnp::_::PointerHelpers< ::ipc::capnp::messages::BlockRef>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::ipc::capnp::messages::BlockRef> Mining::WaitTipChangedResults::Builder::disownResult() {
  return ::capnp::_::PointerHelpers< ::ipc::capnp::messages::BlockRef>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Mining::CreateNewBlockParams::Reader::hasOptions() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Mining::CreateNewBlockParams::Builder::hasOptions() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::ipc::capnp::messages::BlockCreateOptions::Reader Mining::CreateNewBlockParams::Reader::getOptions() const {
  return ::capnp::_::PointerHelpers< ::ipc::capnp::messages::BlockCreateOptions>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::ipc::capnp::messages::BlockCreateOptions::Builder Mining::CreateNewBlockParams::Builder::getOptions() {
  return ::capnp::_::PointerHelpers< ::ipc::capnp::messages::BlockCreateOptions>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::ipc::capnp::messages::BlockCreateOptions::Pipeline Mining::CreateNewBlockParams::Pipeline::getOptions() {
  return  ::ipc::capnp::messages::BlockCreateOptions::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Mining::CreateNewBlockParams::Builder::setOptions( ::ipc::capnp::messages::BlockCreateOptions::Reader value) {
  ::capnp::_::PointerHelpers< ::ipc::capnp::messages::BlockCreateOptions>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::ipc::capnp::messages::BlockCreateOptions::Builder Mining::CreateNewBlockParams::Builder::initOptions() {
  return ::capnp::_::PointerHelpers< ::ipc::capnp::messages::BlockCreateOptions>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Mining::CreateNewBlockParams::Builder::adoptOptions(
    ::capnp::Orphan< ::ipc::capnp::messages::BlockCreateOptions>&& value) {
  ::capnp::_::PointerHelpers< ::ipc::capnp::messages::BlockCreateOptions>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::ipc::capnp::messages::BlockCreateOptions> Mining::CreateNewBlockParams::Builder::disownOptions() {
  return ::capnp::_::PointerHelpers< ::ipc::capnp::messages::BlockCreateOptions>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Mining::CreateNewBlockResults::Reader::hasResult() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Mining::CreateNewBlockResults::Builder::hasResult() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::ipc::capnp::messages::BlockTemplate::Client Mining::CreateNewBlockResults::Reader::getResult() const {
  return ::capnp::_::PointerHelpers< ::ipc::capnp::messages::BlockTemplate>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::ipc::capnp::messages::BlockTemplate::Client Mining::CreateNewBlockResults::Builder::getResult() {
  return ::capnp::_::PointerHelpers< ::ipc::capnp::messages::BlockTemplate>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::ipc::capnp::messages::BlockTemplate::Client Mining::CreateNewBlockResults::Pipeline::getResult() {
  return  ::ipc::capnp::messages::BlockTemplate::Client(_typeless.getPointerField(0).asCap());
}
inline void Mining::CreateNewBlockResults::Builder::setResult( ::ipc::capnp::messages::BlockTemplate::Client&& cap) {
  ::capnp::_::PointerHelpers< ::ipc::capnp::messages::BlockTemplate>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void Mining::CreateNewBlockResults::Builder::setResult( ::ipc::capnp::messages::BlockTemplate::Client& cap) {
  ::capnp::_::PointerHelpers< ::ipc::capnp::messages::BlockTemplate>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void Mining::CreateNewBlockResults::Builder::adoptResult(
    ::capnp::Orphan< ::ipc::capnp::messages::BlockTemplate>&& value) {
  ::capnp::_::PointerHelpers< ::ipc::capnp::messages::BlockTemplate>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::ipc::capnp::messages::BlockTemplate> Mining::CreateNewBlockResults::Builder::disownResult() {
  return ::capnp::_::PointerHelpers< ::ipc::capnp::messages::BlockTemplate>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
inline BlockTemplate::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline BlockTemplate::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline BlockTemplate::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline BlockTemplate::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline BlockTemplate::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::ipc::capnp::messages::BlockTemplate::Client& BlockTemplate::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::ipc::capnp::messages::BlockTemplate::Client& BlockTemplate::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool BlockTemplate::DestroyParams::Reader::hasContext() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool BlockTemplate::DestroyParams::Builder::hasContext() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mp::Context::Reader BlockTemplate::DestroyParams::Reader::getContext() const {
  return ::capnp::_::PointerHelpers< ::mp::Context>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mp::Context::Builder BlockTemplate::DestroyParams::Builder::getContext() {
  return ::capnp::_::PointerHelpers< ::mp::Context>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mp::Context::Pipeline BlockTemplate::DestroyParams::Pipeline::getContext() {
  return  ::mp::Context::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void BlockTemplate::DestroyParams::Builder::setContext( ::mp::Context::Reader value) {
  ::capnp::_::PointerHelpers< ::mp::Context>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mp::Context::Builder BlockTemplate::DestroyParams::Builder::initContext() {
  return ::capnp::_::PointerHelpers< ::mp::Context>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void BlockTemplate::DestroyParams::Builder::adoptContext(
    ::capnp::Orphan< ::mp::Context>&& value) {
  ::capnp::_::PointerHelpers< ::mp::Context>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mp::Context> BlockTemplate::DestroyParams::Builder::disownContext() {
  return ::capnp::_::PointerHelpers< ::mp::Context>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool BlockTemplate::GetBlockHeaderParams::Reader::hasContext() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool BlockTemplate::GetBlockHeaderParams::Builder::hasContext() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mp::Context::Reader BlockTemplate::GetBlockHeaderParams::Reader::getContext() const {
  return ::capnp::_::PointerHelpers< ::mp::Context>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mp::Context::Builder BlockTemplate::GetBlockHeaderParams::Builder::getContext() {
  return ::capnp::_::PointerHelpers< ::mp::Context>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mp::Context::Pipeline BlockTemplate::GetBlockHeaderParams::Pipeline::getContext() {
  return  ::mp::Context::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void BlockTemplate::GetBlockHeaderParams::Builder::setContext( ::mp::Context::Reader value) {
  ::capnp::_::PointerHelpers< ::mp::Context>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mp::Context::Builder BlockTemplate::GetBlockHeaderParams::Builder::initContext() {
  return ::capnp::_::PointerHelpers< ::mp::Context>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void BlockTemplate::GetBlockHeaderParams::Builder::adoptContext(
    ::capnp::Orphan< ::mp::Context>&& value) {
  ::capnp::_::PointerHelpers< ::mp::Context>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mp::Context> BlockTemplate::GetBlockHeaderParams::Builder::disownContext() {
  return ::capnp::_::PointerHelpers< ::mp::Context>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool BlockTemplate::GetBlockHeaderResults::Reader::hasResult() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool BlockTemplate::GetBlockHeaderResults::Builder::hasResult() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Data::Reader BlockTemplate::GetBlockHeaderResults::Reader::getResult() const {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Data::Builder BlockTemplate::GetBlockHeaderResults::Builder::getResult() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void BlockTemplate::GetBlockHeaderResults::Builder::setResult( ::capnp::Data::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Data::Builder BlockTemplate::GetBlockHeaderResults::Builder::initResult(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void BlockTemplate::GetBlockHeaderResults::Builder::adoptResult(
    ::capnp::Orphan< ::capnp::Data>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Data> BlockTemplate::GetBlockHeaderResults::Builder::disownResult() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool BlockTemplate::GetBlockParams::Reader::hasContext() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool BlockTemplate::GetBlockParams::Builder::hasContext() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mp::Context::Reader BlockTemplate::GetBlockParams::Reader::getContext() const {
  return ::capnp::_::PointerHelpers< ::mp::Context>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mp::Context::Builder BlockTemplate::GetBlockParams::Builder::getContext() {
  return ::capnp::_::PointerHelpers< ::mp::Context>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mp::Context::Pipeline BlockTemplate::GetBlockParams::Pipeline::getContext() {
  return  ::mp::Context::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void BlockTemplate::GetBlockParams::Builder::setContext( ::mp::Context::Reader value) {
  ::capnp::_::PointerHelpers< ::mp::Context>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mp::Context::Builder BlockTemplate::GetBlockParams::Builder::initContext() {
  return ::capnp::_::PointerHelpers< ::mp::Context>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void BlockTemplate::GetBlockParams::Builder::adoptContext(
    ::capnp::Orphan< ::mp::Context>&& value) {
  ::capnp::_::PointerHelpers< ::mp::Context>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mp::Context> BlockTemplate::GetBlockParams::Builder::disownContext() {
  return ::capnp::_::PointerHelpers< ::mp::Context>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool BlockTemplate::GetBlockResults::Reader::hasResult() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool BlockTemplate::GetBlockResults::Builder::hasResult() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Data::Reader BlockTemplate::GetBlockResults::Reader::getResult() const {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Data::Builder BlockTemplate::GetBlockResults::Builder::getResult() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void BlockTemplate::GetBlockResults::Builder::setResult( ::capnp::Data::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Data::Builder BlockTemplate::GetBlockResults::Builder::initResult(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void BlockTemplate::GetBlockResults::Builder::adoptResult(
    ::capnp::Orphan< ::capnp::Data>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Data> BlockTemplate::GetBlockResults::Builder::disownResult() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool BlockTemplate::GetTxFeesParams::Reader::hasContext() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool BlockTemplate::GetTxFeesParams::Builder::hasContext() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mp::Context::Reader BlockTemplate::GetTxFeesParams::Reader::getContext() const {
  return ::capnp::_::PointerHelpers< ::mp::Context>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mp::Context::Builder BlockTemplate::GetTxFeesParams::Builder::getContext() {
  return ::capnp::_::PointerHelpers< ::mp::Context>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mp::Context::Pipeline BlockTemplate::GetTxFeesParams::Pipeline::getContext() {
  return  ::mp::Context::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void BlockTemplate::GetTxFeesParams::Builder::setContext( ::mp::Context::Reader value) {
  ::capnp::_::PointerHelpers< ::mp::Context>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mp::Context::Builder BlockTemplate::GetTxFeesParams::Builder::initContext() {
  return ::capnp::_::PointerHelpers< ::mp::Context>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void BlockTemplate::GetTxFeesParams::Builder::adoptContext(
    ::capnp::Orphan< ::mp::Context>&& value) {
  ::capnp::_::PointerHelpers< ::mp::Context>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mp::Context> BlockTemplate::GetTxFeesParams::Builder::disownContext() {
  return ::capnp::_::PointerHelpers< ::mp::Context>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool BlockTemplate::GetTxFeesResults::Reader::hasResult() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool BlockTemplate::GetTxFeesResults::Builder::hasResult() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>::Reader BlockTemplate::GetTxFeesResults::Reader::getResult() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>::Builder BlockTemplate::GetTxFeesResults::Builder::getResult() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void BlockTemplate::GetTxFeesResults::Builder::setResult( ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void BlockTemplate::GetTxFeesResults::Builder::setResult(::kj::ArrayPtr<const  ::int64_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>::Builder BlockTemplate::GetTxFeesResults::Builder::initResult(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void BlockTemplate::GetTxFeesResults::Builder::adoptResult(
    ::capnp::Orphan< ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>> BlockTemplate::GetTxFeesResults::Builder::disownResult() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool BlockTemplate::GetTxSigopsParams::Reader::hasContext() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool BlockTemplate::GetTxSigopsParams::Builder::hasContext() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mp::Context::Reader BlockTemplate::GetTxSigopsParams::Reader::getContext() const {
  return ::capnp::_::PointerHelpers< ::mp::Context>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mp::Context::Builder BlockTemplate::GetTxSigopsParams::Builder::getContext() {
  return ::capnp::_::PointerHelpers< ::mp::Context>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mp::Context::Pipeline BlockTemplate::GetTxSigopsParams::Pipeline::getContext() {
  return  ::mp::Context::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void BlockTemplate::GetTxSigopsParams::Builder::setContext( ::mp::Context::Reader value) {
  ::capnp::_::PointerHelpers< ::mp::Context>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mp::Context::Builder BlockTemplate::GetTxSigopsParams::Builder::initContext() {
  return ::capnp::_::PointerHelpers< ::mp::Context>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void BlockTemplate::GetTxSigopsParams::Builder::adoptContext(
    ::capnp::Orphan< ::mp::Context>&& value) {
  ::capnp::_::PointerHelpers< ::mp::Context>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mp::Context> BlockTemplate::GetTxSigopsParams::Builder::disownContext() {
  return ::capnp::_::PointerHelpers< ::mp::Context>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool BlockTemplate::GetTxSigopsResults::Reader::hasResult() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool BlockTemplate::GetTxSigopsResults::Builder::hasResult() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>::Reader BlockTemplate::GetTxSigopsResults::Reader::getResult() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>::Builder BlockTemplate::GetTxSigopsResults::Builder::getResult() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void BlockTemplate::GetTxSigopsResults::Builder::setResult( ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void BlockTemplate::GetTxSigopsResults::Builder::setResult(::kj::ArrayPtr<const  ::int64_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>::Builder BlockTemplate::GetTxSigopsResults::Builder::initResult(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void BlockTemplate::GetTxSigopsResults::Builder::adoptResult(
    ::capnp::Orphan< ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>> BlockTemplate::GetTxSigopsResults::Builder::disownResult() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool BlockTemplate::GetCoinbaseTxParams::Reader::hasContext() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool BlockTemplate::GetCoinbaseTxParams::Builder::hasContext() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mp::Context::Reader BlockTemplate::GetCoinbaseTxParams::Reader::getContext() const {
  return ::capnp::_::PointerHelpers< ::mp::Context>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mp::Context::Builder BlockTemplate::GetCoinbaseTxParams::Builder::getContext() {
  return ::capnp::_::PointerHelpers< ::mp::Context>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mp::Context::Pipeline BlockTemplate::GetCoinbaseTxParams::Pipeline::getContext() {
  return  ::mp::Context::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void BlockTemplate::GetCoinbaseTxParams::Builder::setContext( ::mp::Context::Reader value) {
  ::capnp::_::PointerHelpers< ::mp::Context>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mp::Context::Builder BlockTemplate::GetCoinbaseTxParams::Builder::initContext() {
  return ::capnp::_::PointerHelpers< ::mp::Context>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void BlockTemplate::GetCoinbaseTxParams::Builder::adoptContext(
    ::capnp::Orphan< ::mp::Context>&& value) {
  ::capnp::_::PointerHelpers< ::mp::Context>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mp::Context> BlockTemplate::GetCoinbaseTxParams::Builder::disownContext() {
  return ::capnp::_::PointerHelpers< ::mp::Context>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool BlockTemplate::GetCoinbaseTxResults::Reader::hasResult() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool BlockTemplate::GetCoinbaseTxResults::Builder::hasResult() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Data::Reader BlockTemplate::GetCoinbaseTxResults::Reader::getResult() const {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Data::Builder BlockTemplate::GetCoinbaseTxResults::Builder::getResult() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void BlockTemplate::GetCoinbaseTxResults::Builder::setResult( ::capnp::Data::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Data::Builder BlockTemplate::GetCoinbaseTxResults::Builder::initResult(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void BlockTemplate::GetCoinbaseTxResults::Builder::adoptResult(
    ::capnp::Orphan< ::capnp::Data>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Data> BlockTemplate::GetCoinbaseTxResults::Builder::disownResult() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool BlockTemplate::GetCoinbaseCommitmentParams::Reader::hasContext() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool BlockTemplate::GetCoinbaseCommitmentParams::Builder::hasContext() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mp::Context::Reader BlockTemplate::GetCoinbaseCommitmentParams::Reader::getContext() const {
  return ::capnp::_::PointerHelpers< ::mp::Context>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mp::Context::Builder BlockTemplate::GetCoinbaseCommitmentParams::Builder::getContext() {
  return ::capnp::_::PointerHelpers< ::mp::Context>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mp::Context::Pipeline BlockTemplate::GetCoinbaseCommitmentParams::Pipeline::getContext() {
  return  ::mp::Context::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void BlockTemplate::GetCoinbaseCommitmentParams::Builder::setContext( ::mp::Context::Reader value) {
  ::capnp::_::PointerHelpers< ::mp::Context>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mp::Context::Builder BlockTemplate::GetCoinbaseCommitmentParams::Builder::initContext() {
  return ::capnp::_::PointerHelpers< ::mp::Context>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void BlockTemplate::GetCoinbaseCommitmentParams::Builder::adoptContext(
    ::capnp::Orphan< ::mp::Context>&& value) {
  ::capnp::_::PointerHelpers< ::mp::Context>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mp::Context> BlockTemplate::GetCoinbaseCommitmentParams::Builder::disownContext() {
  return ::capnp::_::PointerHelpers< ::mp::Context>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool BlockTemplate::GetCoinbaseCommitmentResults::Reader::hasResult() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool BlockTemplate::GetCoinbaseCommitmentResults::Builder::hasResult() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Data::Reader BlockTemplate::GetCoinbaseCommitmentResults::Reader::getResult() const {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Data::Builder BlockTemplate::GetCoinbaseCommitmentResults::Builder::getResult() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void BlockTemplate::GetCoinbaseCommitmentResults::Builder::setResult( ::capnp::Data::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Data::Builder BlockTemplate::GetCoinbaseCommitmentResults::Builder::initResult(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void BlockTemplate::GetCoinbaseCommitmentResults::Builder::adoptResult(
    ::capnp::Orphan< ::capnp::Data>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Data> BlockTemplate::GetCoinbaseCommitmentResults::Builder::disownResult() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool BlockTemplate::GetWitnessCommitmentIndexParams::Reader::hasContext() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool BlockTemplate::GetWitnessCommitmentIndexParams::Builder::hasContext() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mp::Context::Reader BlockTemplate::GetWitnessCommitmentIndexParams::Reader::getContext() const {
  return ::capnp::_::PointerHelpers< ::mp::Context>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mp::Context::Builder BlockTemplate::GetWitnessCommitmentIndexParams::Builder::getContext() {
  return ::capnp::_::PointerHelpers< ::mp::Context>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mp::Context::Pipeline BlockTemplate::GetWitnessCommitmentIndexParams::Pipeline::getContext() {
  return  ::mp::Context::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void BlockTemplate::GetWitnessCommitmentIndexParams::Builder::setContext( ::mp::Context::Reader value) {
  ::capnp::_::PointerHelpers< ::mp::Context>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mp::Context::Builder BlockTemplate::GetWitnessCommitmentIndexParams::Builder::initContext() {
  return ::capnp::_::PointerHelpers< ::mp::Context>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void BlockTemplate::GetWitnessCommitmentIndexParams::Builder::adoptContext(
    ::capnp::Orphan< ::mp::Context>&& value) {
  ::capnp::_::PointerHelpers< ::mp::Context>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mp::Context> BlockTemplate::GetWitnessCommitmentIndexParams::Builder::disownContext() {
  return ::capnp::_::PointerHelpers< ::mp::Context>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::int32_t BlockTemplate::GetWitnessCommitmentIndexResults::Reader::getResult() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t BlockTemplate::GetWitnessCommitmentIndexResults::Builder::getResult() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void BlockTemplate::GetWitnessCommitmentIndexResults::Builder::setResult( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool BlockTemplate::GetCoinbaseMerklePathParams::Reader::hasContext() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool BlockTemplate::GetCoinbaseMerklePathParams::Builder::hasContext() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mp::Context::Reader BlockTemplate::GetCoinbaseMerklePathParams::Reader::getContext() const {
  return ::capnp::_::PointerHelpers< ::mp::Context>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mp::Context::Builder BlockTemplate::GetCoinbaseMerklePathParams::Builder::getContext() {
  return ::capnp::_::PointerHelpers< ::mp::Context>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mp::Context::Pipeline BlockTemplate::GetCoinbaseMerklePathParams::Pipeline::getContext() {
  return  ::mp::Context::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void BlockTemplate::GetCoinbaseMerklePathParams::Builder::setContext( ::mp::Context::Reader value) {
  ::capnp::_::PointerHelpers< ::mp::Context>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mp::Context::Builder BlockTemplate::GetCoinbaseMerklePathParams::Builder::initContext() {
  return ::capnp::_::PointerHelpers< ::mp::Context>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void BlockTemplate::GetCoinbaseMerklePathParams::Builder::adoptContext(
    ::capnp::Orphan< ::mp::Context>&& value) {
  ::capnp::_::PointerHelpers< ::mp::Context>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mp::Context> BlockTemplate::GetCoinbaseMerklePathParams::Builder::disownContext() {
  return ::capnp::_::PointerHelpers< ::mp::Context>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool BlockTemplate::GetCoinbaseMerklePathResults::Reader::hasResult() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool BlockTemplate::GetCoinbaseMerklePathResults::Builder::hasResult() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>::Reader BlockTemplate::GetCoinbaseMerklePathResults::Reader::getResult() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>::Builder BlockTemplate::GetCoinbaseMerklePathResults::Builder::getResult() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void BlockTemplate::GetCoinbaseMerklePathResults::Builder::setResult( ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void BlockTemplate::GetCoinbaseMerklePathResults::Builder::setResult(::kj::ArrayPtr<const  ::capnp::Data::Reader> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>::Builder BlockTemplate::GetCoinbaseMerklePathResults::Builder::initResult(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void BlockTemplate::GetCoinbaseMerklePathResults::Builder::adoptResult(
    ::capnp::Orphan< ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>> BlockTemplate::GetCoinbaseMerklePathResults::Builder::disownResult() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Data,  ::capnp::Kind::BLOB>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool BlockTemplate::SubmitSolutionParams::Reader::hasContext() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool BlockTemplate::SubmitSolutionParams::Builder::hasContext() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mp::Context::Reader BlockTemplate::SubmitSolutionParams::Reader::getContext() const {
  return ::capnp::_::PointerHelpers< ::mp::Context>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mp::Context::Builder BlockTemplate::SubmitSolutionParams::Builder::getContext() {
  return ::capnp::_::PointerHelpers< ::mp::Context>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mp::Context::Pipeline BlockTemplate::SubmitSolutionParams::Pipeline::getContext() {
  return  ::mp::Context::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void BlockTemplate::SubmitSolutionParams::Builder::setContext( ::mp::Context::Reader value) {
  ::capnp::_::PointerHelpers< ::mp::Context>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mp::Context::Builder BlockTemplate::SubmitSolutionParams::Builder::initContext() {
  return ::capnp::_::PointerHelpers< ::mp::Context>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void BlockTemplate::SubmitSolutionParams::Builder::adoptContext(
    ::capnp::Orphan< ::mp::Context>&& value) {
  ::capnp::_::PointerHelpers< ::mp::Context>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mp::Context> BlockTemplate::SubmitSolutionParams::Builder::disownContext() {
  return ::capnp::_::PointerHelpers< ::mp::Context>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint32_t BlockTemplate::SubmitSolutionParams::Reader::getVersion() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t BlockTemplate::SubmitSolutionParams::Builder::getVersion() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void BlockTemplate::SubmitSolutionParams::Builder::setVersion( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t BlockTemplate::SubmitSolutionParams::Reader::getTimestamp() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t BlockTemplate::SubmitSolutionParams::Builder::getTimestamp() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void BlockTemplate::SubmitSolutionParams::Builder::setTimestamp( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t BlockTemplate::SubmitSolutionParams::Reader::getNonce() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t BlockTemplate::SubmitSolutionParams::Builder::getNonce() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void BlockTemplate::SubmitSolutionParams::Builder::setNonce( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool BlockTemplate::SubmitSolutionParams::Reader::hasCoinbase() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool BlockTemplate::SubmitSolutionParams::Builder::hasCoinbase() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Data::Reader BlockTemplate::SubmitSolutionParams::Reader::getCoinbase() const {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Data::Builder BlockTemplate::SubmitSolutionParams::Builder::getCoinbase() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void BlockTemplate::SubmitSolutionParams::Builder::setCoinbase( ::capnp::Data::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Data::Builder BlockTemplate::SubmitSolutionParams::Builder::initCoinbase(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void BlockTemplate::SubmitSolutionParams::Builder::adoptCoinbase(
    ::capnp::Orphan< ::capnp::Data>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Data> BlockTemplate::SubmitSolutionParams::Builder::disownCoinbase() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool BlockTemplate::SubmitSolutionResults::Reader::getResult() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool BlockTemplate::SubmitSolutionResults::Builder::getResult() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void BlockTemplate::SubmitSolutionResults::Builder::setResult(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool BlockCreateOptions::Reader::getUseMempool() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool BlockCreateOptions::Builder::getUseMempool() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void BlockCreateOptions::Builder::setUseMempool(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t BlockCreateOptions::Reader::getBlockReservedWeight() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t BlockCreateOptions::Builder::getBlockReservedWeight() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void BlockCreateOptions::Builder::setBlockReservedWeight( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t BlockCreateOptions::Reader::getCoinbaseOutputMaxAdditionalSigops() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t BlockCreateOptions::Builder::getCoinbaseOutputMaxAdditionalSigops() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void BlockCreateOptions::Builder::setCoinbaseOutputMaxAdditionalSigops( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t BlockValidationState::Reader::getMode() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t BlockValidationState::Builder::getMode() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void BlockValidationState::Builder::setMode( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t BlockValidationState::Reader::getResult() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int32_t BlockValidationState::Builder::getResult() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void BlockValidationState::Builder::setResult( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool BlockValidationState::Reader::hasRejectReason() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool BlockValidationState::Builder::hasRejectReason() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader BlockValidationState::Reader::getRejectReason() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder BlockValidationState::Builder::getRejectReason() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void BlockValidationState::Builder::setRejectReason( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder BlockValidationState::Builder::initRejectReason(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void BlockValidationState::Builder::adoptRejectReason(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> BlockValidationState::Builder::disownRejectReason() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool BlockValidationState::Reader::hasDebugMessage() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool BlockValidationState::Builder::hasDebugMessage() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader BlockValidationState::Reader::getDebugMessage() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder BlockValidationState::Builder::getDebugMessage() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void BlockValidationState::Builder::setDebugMessage( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder BlockValidationState::Builder::initDebugMessage(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void BlockValidationState::Builder::adoptDebugMessage(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> BlockValidationState::Builder::disownDebugMessage() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

}  // namespace
}  // namespace
}  // namespace

CAPNP_END_HEADER

