// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: common.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>

#ifndef CAPNP_VERSION
#error "CAPNP_VERSION is not defined, is capnp/generated-header-support.h missing?"
#elif CAPNP_VERSION != 1000001
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif


CAPNP_BEGIN_HEADER

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(b3be4b8949350369);
CAPNP_DECLARE_SCHEMA(8ab5bd30b9c0e6b8);
CAPNP_DECLARE_SCHEMA(e9ccda4c4ecfcc58);
CAPNP_DECLARE_SCHEMA(c55a33a945f4410c);
CAPNP_DECLARE_SCHEMA(8ef2f6fc4199a71e);
CAPNP_DECLARE_SCHEMA(b6061f707b66a314);

}  // namespace schemas
}  // namespace capnp

namespace ipc {
namespace capnp {
namespace messages {

struct BlockRef {
  BlockRef() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b3be4b8949350369, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct BilingualStr {
  BilingualStr() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8ab5bd30b9c0e6b8, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

template <typename Value = ::capnp::AnyPointer>
struct Result {
  Result() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e9ccda4c4ecfcc58, 0, 2)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, Value>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename Value = ::capnp::AnyPointer>
struct ResultVoid {
  ResultVoid() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c55a33a945f4410c, 0, 1)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, Value>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename Key = ::capnp::AnyPointer, typename Value = ::capnp::AnyPointer>
struct Pair {
  Pair() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8ef2f6fc4199a71e, 0, 2)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, Key, Value>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename Key = ::capnp::AnyPointer>
struct PairInt64 {
  PairInt64() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b6061f707b66a314, 1, 1)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, Key>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class BlockRef::Reader {
public:
  typedef BlockRef Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasHash() const;
  inline  ::capnp::Data::Reader getHash() const;

  inline  ::int32_t getHeight() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class BlockRef::Builder {
public:
  typedef BlockRef Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHash();
  inline  ::capnp::Data::Builder getHash();
  inline void setHash( ::capnp::Data::Reader value);
  inline  ::capnp::Data::Builder initHash(unsigned int size);
  inline void adoptHash(::capnp::Orphan< ::capnp::Data>&& value);
  inline ::capnp::Orphan< ::capnp::Data> disownHash();

  inline  ::int32_t getHeight();
  inline void setHeight( ::int32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class BlockRef::Pipeline {
public:
  typedef BlockRef Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class BilingualStr::Reader {
public:
  typedef BilingualStr Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasOriginal() const;
  inline  ::capnp::Text::Reader getOriginal() const;

  inline bool hasTranslated() const;
  inline  ::capnp::Text::Reader getTranslated() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class BilingualStr::Builder {
public:
  typedef BilingualStr Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasOriginal();
  inline  ::capnp::Text::Builder getOriginal();
  inline void setOriginal( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initOriginal(unsigned int size);
  inline void adoptOriginal(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownOriginal();

  inline bool hasTranslated();
  inline  ::capnp::Text::Builder getTranslated();
  inline void setTranslated( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initTranslated(unsigned int size);
  inline void adoptTranslated(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownTranslated();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class BilingualStr::Pipeline {
public:
  typedef BilingualStr Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename Value>
class Result<Value>::Reader {
public:
  typedef Result Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename Value2 = ::capnp::AnyPointer>
  typename Result<Value2>::Reader asGeneric() {
    return typename Result<Value2>::Reader(_reader);
  }

  inline bool hasValue() const;
  inline  ::capnp::ReaderFor<Value> getValue() const;

  inline bool hasError() const;
  inline  ::ipc::capnp::messages::BilingualStr::Reader getError() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename Value>
class Result<Value>::Builder {
public:
  typedef Result Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename Value2 = ::capnp::AnyPointer>
  typename Result<Value2>::Builder asGeneric() {
    return typename Result<Value2>::Builder(_builder);
  }

  inline bool hasValue();
  inline  ::capnp::BuilderFor<Value> getValue();
  inline void setValue( ::capnp::ReaderFor<Value> value);
  inline  ::capnp::BuilderFor<Value> initValue();
  inline  ::capnp::BuilderFor<Value> initValue(unsigned int size);
  inline void adoptValue(::capnp::Orphan<Value>&& value);
  inline ::capnp::Orphan<Value> disownValue();

  inline bool hasError();
  inline  ::ipc::capnp::messages::BilingualStr::Builder getError();
  inline void setError( ::ipc::capnp::messages::BilingualStr::Reader value);
  inline  ::ipc::capnp::messages::BilingualStr::Builder initError();
  inline void adoptError(::capnp::Orphan< ::ipc::capnp::messages::BilingualStr>&& value);
  inline ::capnp::Orphan< ::ipc::capnp::messages::BilingualStr> disownError();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename Value>
class Result<Value>::Pipeline {
public:
  typedef Result Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::PipelineFor<Value> getValue();
  inline  ::ipc::capnp::messages::BilingualStr::Pipeline getError();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename Value>
class ResultVoid<Value>::Reader {
public:
  typedef ResultVoid Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename Value2 = ::capnp::AnyPointer>
  typename ResultVoid<Value2>::Reader asGeneric() {
    return typename ResultVoid<Value2>::Reader(_reader);
  }

  inline bool hasError() const;
  inline  ::ipc::capnp::messages::BilingualStr::Reader getError() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename Value>
class ResultVoid<Value>::Builder {
public:
  typedef ResultVoid Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename Value2 = ::capnp::AnyPointer>
  typename ResultVoid<Value2>::Builder asGeneric() {
    return typename ResultVoid<Value2>::Builder(_builder);
  }

  inline bool hasError();
  inline  ::ipc::capnp::messages::BilingualStr::Builder getError();
  inline void setError( ::ipc::capnp::messages::BilingualStr::Reader value);
  inline  ::ipc::capnp::messages::BilingualStr::Builder initError();
  inline void adoptError(::capnp::Orphan< ::ipc::capnp::messages::BilingualStr>&& value);
  inline ::capnp::Orphan< ::ipc::capnp::messages::BilingualStr> disownError();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename Value>
class ResultVoid<Value>::Pipeline {
public:
  typedef ResultVoid Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::ipc::capnp::messages::BilingualStr::Pipeline getError();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename Key, typename Value>
class Pair<Key, Value>::Reader {
public:
  typedef Pair Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename Key2 = ::capnp::AnyPointer, typename Value2 = ::capnp::AnyPointer>
  typename Pair<Key2, Value2>::Reader asGeneric() {
    return typename Pair<Key2, Value2>::Reader(_reader);
  }

  inline bool hasKey() const;
  inline  ::capnp::ReaderFor<Key> getKey() const;

  inline bool hasValue() const;
  inline  ::capnp::ReaderFor<Value> getValue() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename Key, typename Value>
class Pair<Key, Value>::Builder {
public:
  typedef Pair Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename Key2 = ::capnp::AnyPointer, typename Value2 = ::capnp::AnyPointer>
  typename Pair<Key2, Value2>::Builder asGeneric() {
    return typename Pair<Key2, Value2>::Builder(_builder);
  }

  inline bool hasKey();
  inline  ::capnp::BuilderFor<Key> getKey();
  inline void setKey( ::capnp::ReaderFor<Key> value);
  inline  ::capnp::BuilderFor<Key> initKey();
  inline  ::capnp::BuilderFor<Key> initKey(unsigned int size);
  inline void adoptKey(::capnp::Orphan<Key>&& value);
  inline ::capnp::Orphan<Key> disownKey();

  inline bool hasValue();
  inline  ::capnp::BuilderFor<Value> getValue();
  inline void setValue( ::capnp::ReaderFor<Value> value);
  inline  ::capnp::BuilderFor<Value> initValue();
  inline  ::capnp::BuilderFor<Value> initValue(unsigned int size);
  inline void adoptValue(::capnp::Orphan<Value>&& value);
  inline ::capnp::Orphan<Value> disownValue();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename Key, typename Value>
class Pair<Key, Value>::Pipeline {
public:
  typedef Pair Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::PipelineFor<Key> getKey();
  inline  ::capnp::PipelineFor<Value> getValue();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename Key>
class PairInt64<Key>::Reader {
public:
  typedef PairInt64 Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename Key2 = ::capnp::AnyPointer>
  typename PairInt64<Key2>::Reader asGeneric() {
    return typename PairInt64<Key2>::Reader(_reader);
  }

  inline bool hasKey() const;
  inline  ::capnp::ReaderFor<Key> getKey() const;

  inline  ::int64_t getValue() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename Key>
class PairInt64<Key>::Builder {
public:
  typedef PairInt64 Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename Key2 = ::capnp::AnyPointer>
  typename PairInt64<Key2>::Builder asGeneric() {
    return typename PairInt64<Key2>::Builder(_builder);
  }

  inline bool hasKey();
  inline  ::capnp::BuilderFor<Key> getKey();
  inline void setKey( ::capnp::ReaderFor<Key> value);
  inline  ::capnp::BuilderFor<Key> initKey();
  inline  ::capnp::BuilderFor<Key> initKey(unsigned int size);
  inline void adoptKey(::capnp::Orphan<Key>&& value);
  inline ::capnp::Orphan<Key> disownKey();

  inline  ::int64_t getValue();
  inline void setValue( ::int64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename Key>
class PairInt64<Key>::Pipeline {
public:
  typedef PairInt64 Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::PipelineFor<Key> getKey();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline bool BlockRef::Reader::hasHash() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool BlockRef::Builder::hasHash() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Data::Reader BlockRef::Reader::getHash() const {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Data::Builder BlockRef::Builder::getHash() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void BlockRef::Builder::setHash( ::capnp::Data::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Data::Builder BlockRef::Builder::initHash(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void BlockRef::Builder::adoptHash(
    ::capnp::Orphan< ::capnp::Data>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Data> BlockRef::Builder::disownHash() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::int32_t BlockRef::Reader::getHeight() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t BlockRef::Builder::getHeight() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void BlockRef::Builder::setHeight( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool BilingualStr::Reader::hasOriginal() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool BilingualStr::Builder::hasOriginal() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader BilingualStr::Reader::getOriginal() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder BilingualStr::Builder::getOriginal() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void BilingualStr::Builder::setOriginal( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder BilingualStr::Builder::initOriginal(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void BilingualStr::Builder::adoptOriginal(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> BilingualStr::Builder::disownOriginal() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool BilingualStr::Reader::hasTranslated() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool BilingualStr::Builder::hasTranslated() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader BilingualStr::Reader::getTranslated() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder BilingualStr::Builder::getTranslated() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void BilingualStr::Builder::setTranslated( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder BilingualStr::Builder::initTranslated(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void BilingualStr::Builder::adoptTranslated(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> BilingualStr::Builder::disownTranslated() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

template <typename Value>
inline bool Result<Value>::Reader::hasValue() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Value>
inline bool Result<Value>::Builder::hasValue() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Value>
inline  ::capnp::ReaderFor<Value> Result<Value>::Reader::getValue() const {
  return ::capnp::_::PointerHelpers<Value>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Value>
inline  ::capnp::BuilderFor<Value> Result<Value>::Builder::getValue() {
  return ::capnp::_::PointerHelpers<Value>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename Value>
inline  ::capnp::PipelineFor<Value> Result<Value>::Pipeline::getValue() {
  return  ::capnp::PipelineFor<Value>(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
template <typename Value>
inline void Result<Value>::Builder::setValue( ::capnp::ReaderFor<Value> value) {
  ::capnp::_::PointerHelpers<Value>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename Value>
inline  ::capnp::BuilderFor<Value> Result<Value>::Builder::initValue() {
  return ::capnp::_::PointerHelpers<Value>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Value>
inline  ::capnp::BuilderFor<Value> Result<Value>::Builder::initValue(unsigned int size) {
  return ::capnp::_::PointerHelpers<Value>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename Value>
inline void Result<Value>::Builder::adoptValue(
    ::capnp::Orphan<Value>&& value) {
  ::capnp::_::PointerHelpers<Value>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename Value>
inline ::capnp::Orphan<Value> Result<Value>::Builder::disownValue() {
  return ::capnp::_::PointerHelpers<Value>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

template <typename Value>
inline bool Result<Value>::Reader::hasError() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename Value>
inline bool Result<Value>::Builder::hasError() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename Value>
inline  ::ipc::capnp::messages::BilingualStr::Reader Result<Value>::Reader::getError() const {
  return ::capnp::_::PointerHelpers< ::ipc::capnp::messages::BilingualStr>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename Value>
inline  ::ipc::capnp::messages::BilingualStr::Builder Result<Value>::Builder::getError() {
  return ::capnp::_::PointerHelpers< ::ipc::capnp::messages::BilingualStr>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename Value>
inline  ::ipc::capnp::messages::BilingualStr::Pipeline Result<Value>::Pipeline::getError() {
  return  ::ipc::capnp::messages::BilingualStr::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
template <typename Value>
inline void Result<Value>::Builder::setError( ::ipc::capnp::messages::BilingualStr::Reader value) {
  ::capnp::_::PointerHelpers< ::ipc::capnp::messages::BilingualStr>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
template <typename Value>
inline  ::ipc::capnp::messages::BilingualStr::Builder Result<Value>::Builder::initError() {
  return ::capnp::_::PointerHelpers< ::ipc::capnp::messages::BilingualStr>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename Value>
inline void Result<Value>::Builder::adoptError(
    ::capnp::Orphan< ::ipc::capnp::messages::BilingualStr>&& value) {
  ::capnp::_::PointerHelpers< ::ipc::capnp::messages::BilingualStr>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename Value>
inline ::capnp::Orphan< ::ipc::capnp::messages::BilingualStr> Result<Value>::Builder::disownError() {
  return ::capnp::_::PointerHelpers< ::ipc::capnp::messages::BilingualStr>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

// Result<Value>
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename Value>
constexpr uint16_t Result<Value>::_capnpPrivate::dataWordSize;
template <typename Value>
constexpr uint16_t Result<Value>::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename Value>
constexpr ::capnp::Kind Result<Value>::_capnpPrivate::kind;
template <typename Value>
constexpr ::capnp::_::RawSchema const* Result<Value>::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename Value>
const ::capnp::_::RawBrandedSchema::Scope Result<Value>::_capnpPrivate::brandScopes[] = {
  { 0xe9ccda4c4ecfcc58, brandBindings + 0, 1, false},
};
template <typename Value>
const ::capnp::_::RawBrandedSchema::Binding Result<Value>::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<Value>(),
};
template <typename Value>
const ::capnp::_::RawBrandedSchema Result<Value>::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_e9ccda4c4ecfcc58, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

template <typename Value>
inline bool ResultVoid<Value>::Reader::hasError() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Value>
inline bool ResultVoid<Value>::Builder::hasError() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Value>
inline  ::ipc::capnp::messages::BilingualStr::Reader ResultVoid<Value>::Reader::getError() const {
  return ::capnp::_::PointerHelpers< ::ipc::capnp::messages::BilingualStr>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Value>
inline  ::ipc::capnp::messages::BilingualStr::Builder ResultVoid<Value>::Builder::getError() {
  return ::capnp::_::PointerHelpers< ::ipc::capnp::messages::BilingualStr>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename Value>
inline  ::ipc::capnp::messages::BilingualStr::Pipeline ResultVoid<Value>::Pipeline::getError() {
  return  ::ipc::capnp::messages::BilingualStr::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
template <typename Value>
inline void ResultVoid<Value>::Builder::setError( ::ipc::capnp::messages::BilingualStr::Reader value) {
  ::capnp::_::PointerHelpers< ::ipc::capnp::messages::BilingualStr>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename Value>
inline  ::ipc::capnp::messages::BilingualStr::Builder ResultVoid<Value>::Builder::initError() {
  return ::capnp::_::PointerHelpers< ::ipc::capnp::messages::BilingualStr>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Value>
inline void ResultVoid<Value>::Builder::adoptError(
    ::capnp::Orphan< ::ipc::capnp::messages::BilingualStr>&& value) {
  ::capnp::_::PointerHelpers< ::ipc::capnp::messages::BilingualStr>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename Value>
inline ::capnp::Orphan< ::ipc::capnp::messages::BilingualStr> ResultVoid<Value>::Builder::disownError() {
  return ::capnp::_::PointerHelpers< ::ipc::capnp::messages::BilingualStr>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

// ResultVoid<Value>
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename Value>
constexpr uint16_t ResultVoid<Value>::_capnpPrivate::dataWordSize;
template <typename Value>
constexpr uint16_t ResultVoid<Value>::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename Value>
constexpr ::capnp::Kind ResultVoid<Value>::_capnpPrivate::kind;
template <typename Value>
constexpr ::capnp::_::RawSchema const* ResultVoid<Value>::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename Value>
const ::capnp::_::RawBrandedSchema::Scope ResultVoid<Value>::_capnpPrivate::brandScopes[] = {
  { 0xc55a33a945f4410c, brandBindings + 0, 1, false},
};
template <typename Value>
const ::capnp::_::RawBrandedSchema::Binding ResultVoid<Value>::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<Value>(),
};
template <typename Value>
const ::capnp::_::RawBrandedSchema ResultVoid<Value>::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_c55a33a945f4410c, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

template <typename Key, typename Value>
inline bool Pair<Key, Value>::Reader::hasKey() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Key, typename Value>
inline bool Pair<Key, Value>::Builder::hasKey() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Key, typename Value>
inline  ::capnp::ReaderFor<Key> Pair<Key, Value>::Reader::getKey() const {
  return ::capnp::_::PointerHelpers<Key>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Key, typename Value>
inline  ::capnp::BuilderFor<Key> Pair<Key, Value>::Builder::getKey() {
  return ::capnp::_::PointerHelpers<Key>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename Key, typename Value>
inline  ::capnp::PipelineFor<Key> Pair<Key, Value>::Pipeline::getKey() {
  return  ::capnp::PipelineFor<Key>(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
template <typename Key, typename Value>
inline void Pair<Key, Value>::Builder::setKey( ::capnp::ReaderFor<Key> value) {
  ::capnp::_::PointerHelpers<Key>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename Key, typename Value>
inline  ::capnp::BuilderFor<Key> Pair<Key, Value>::Builder::initKey() {
  return ::capnp::_::PointerHelpers<Key>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Key, typename Value>
inline  ::capnp::BuilderFor<Key> Pair<Key, Value>::Builder::initKey(unsigned int size) {
  return ::capnp::_::PointerHelpers<Key>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename Key, typename Value>
inline void Pair<Key, Value>::Builder::adoptKey(
    ::capnp::Orphan<Key>&& value) {
  ::capnp::_::PointerHelpers<Key>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename Key, typename Value>
inline ::capnp::Orphan<Key> Pair<Key, Value>::Builder::disownKey() {
  return ::capnp::_::PointerHelpers<Key>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

template <typename Key, typename Value>
inline bool Pair<Key, Value>::Reader::hasValue() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename Key, typename Value>
inline bool Pair<Key, Value>::Builder::hasValue() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename Key, typename Value>
inline  ::capnp::ReaderFor<Value> Pair<Key, Value>::Reader::getValue() const {
  return ::capnp::_::PointerHelpers<Value>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename Key, typename Value>
inline  ::capnp::BuilderFor<Value> Pair<Key, Value>::Builder::getValue() {
  return ::capnp::_::PointerHelpers<Value>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename Key, typename Value>
inline  ::capnp::PipelineFor<Value> Pair<Key, Value>::Pipeline::getValue() {
  return  ::capnp::PipelineFor<Value>(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
template <typename Key, typename Value>
inline void Pair<Key, Value>::Builder::setValue( ::capnp::ReaderFor<Value> value) {
  ::capnp::_::PointerHelpers<Value>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
template <typename Key, typename Value>
inline  ::capnp::BuilderFor<Value> Pair<Key, Value>::Builder::initValue() {
  return ::capnp::_::PointerHelpers<Value>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename Key, typename Value>
inline  ::capnp::BuilderFor<Value> Pair<Key, Value>::Builder::initValue(unsigned int size) {
  return ::capnp::_::PointerHelpers<Value>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
template <typename Key, typename Value>
inline void Pair<Key, Value>::Builder::adoptValue(
    ::capnp::Orphan<Value>&& value) {
  ::capnp::_::PointerHelpers<Value>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename Key, typename Value>
inline ::capnp::Orphan<Value> Pair<Key, Value>::Builder::disownValue() {
  return ::capnp::_::PointerHelpers<Value>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

// Pair<Key, Value>
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename Key, typename Value>
constexpr uint16_t Pair<Key, Value>::_capnpPrivate::dataWordSize;
template <typename Key, typename Value>
constexpr uint16_t Pair<Key, Value>::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename Key, typename Value>
constexpr ::capnp::Kind Pair<Key, Value>::_capnpPrivate::kind;
template <typename Key, typename Value>
constexpr ::capnp::_::RawSchema const* Pair<Key, Value>::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename Key, typename Value>
const ::capnp::_::RawBrandedSchema::Scope Pair<Key, Value>::_capnpPrivate::brandScopes[] = {
  { 0x8ef2f6fc4199a71e, brandBindings + 0, 2, false},
};
template <typename Key, typename Value>
const ::capnp::_::RawBrandedSchema::Binding Pair<Key, Value>::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<Key>(),
  ::capnp::_::brandBindingFor<Value>(),
};
template <typename Key, typename Value>
const ::capnp::_::RawBrandedSchema Pair<Key, Value>::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_8ef2f6fc4199a71e, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

template <typename Key>
inline bool PairInt64<Key>::Reader::hasKey() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Key>
inline bool PairInt64<Key>::Builder::hasKey() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Key>
inline  ::capnp::ReaderFor<Key> PairInt64<Key>::Reader::getKey() const {
  return ::capnp::_::PointerHelpers<Key>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Key>
inline  ::capnp::BuilderFor<Key> PairInt64<Key>::Builder::getKey() {
  return ::capnp::_::PointerHelpers<Key>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename Key>
inline  ::capnp::PipelineFor<Key> PairInt64<Key>::Pipeline::getKey() {
  return  ::capnp::PipelineFor<Key>(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
template <typename Key>
inline void PairInt64<Key>::Builder::setKey( ::capnp::ReaderFor<Key> value) {
  ::capnp::_::PointerHelpers<Key>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename Key>
inline  ::capnp::BuilderFor<Key> PairInt64<Key>::Builder::initKey() {
  return ::capnp::_::PointerHelpers<Key>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Key>
inline  ::capnp::BuilderFor<Key> PairInt64<Key>::Builder::initKey(unsigned int size) {
  return ::capnp::_::PointerHelpers<Key>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename Key>
inline void PairInt64<Key>::Builder::adoptKey(
    ::capnp::Orphan<Key>&& value) {
  ::capnp::_::PointerHelpers<Key>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename Key>
inline ::capnp::Orphan<Key> PairInt64<Key>::Builder::disownKey() {
  return ::capnp::_::PointerHelpers<Key>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

template <typename Key>
inline  ::int64_t PairInt64<Key>::Reader::getValue() const {
  return _reader.getDataField< ::int64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

template <typename Key>
inline  ::int64_t PairInt64<Key>::Builder::getValue() {
  return _builder.getDataField< ::int64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
template <typename Key>
inline void PairInt64<Key>::Builder::setValue( ::int64_t value) {
  _builder.setDataField< ::int64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

// PairInt64<Key>
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename Key>
constexpr uint16_t PairInt64<Key>::_capnpPrivate::dataWordSize;
template <typename Key>
constexpr uint16_t PairInt64<Key>::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename Key>
constexpr ::capnp::Kind PairInt64<Key>::_capnpPrivate::kind;
template <typename Key>
constexpr ::capnp::_::RawSchema const* PairInt64<Key>::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename Key>
const ::capnp::_::RawBrandedSchema::Scope PairInt64<Key>::_capnpPrivate::brandScopes[] = {
  { 0xb6061f707b66a314, brandBindings + 0, 1, false},
};
template <typename Key>
const ::capnp::_::RawBrandedSchema::Binding PairInt64<Key>::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<Key>(),
};
template <typename Key>
const ::capnp::_::RawBrandedSchema PairInt64<Key>::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_b6061f707b66a314, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

}  // namespace
}  // namespace
}  // namespace

CAPNP_END_HEADER

